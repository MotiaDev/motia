{
  "content": "---\n# File: docs/core/defining-steps.mdx\n\n---\nsidebar_position: 3\ntitle: Defining Steps\n---\n\nThe anatomy of a **Step** - steps are composed of the following key components:\n\n## Config\n\nAn exported **config** object describing the following details\n\n<DescriptionTable\n  type={{\n    type: {\n      description: 'Defines the type of step, which can be one of the following values: `event`, `api`, or `cron`',\n      type: 'string',\n    },\n    name: {\n      description: 'Name assigned to your step, displayed in the workbench flow visualization tool',\n      type: 'string',\n    },\n    subscribes: {\n      description: 'A list of topics your step subscribes',\n      type: 'string[]',\n      default: []\n    },\n    emits: {\n      description: 'A list of topics your step emits',\n      type: 'string[]',\n    },\n    flows: {\n      description: 'A list of flows your step is associated',\n      type: 'string[]',\n    },\n    description: {\n      description: 'A small description of your step, this is not required, but it will be helpful for the workbench flow visualization tool',\n      type: 'string',\n    }\n  }}\n/>\n\n#### The following props are specific to each step type\n\n<Callout type=\"warn\">API steps are only supported in TS or JS</Callout>\nTODO: This section and the section with the code below it need some kind of box around them. Because they are seperated with their own bounding boxes it is a little confusing.\n<Tabs items={['event', 'api', 'cron']}>\n  <Tab value='event'>\n    TODO: Need a brief description of event steps. What do they do? What are they use for?\n    <DescriptionTable\n      type={{\n        input: {\n          description: 'This is only required for TS or JS steps that use zod for their input schema, this is used when processing the step to validate the input before executing the step handler.',\n          type: 'string[]',\n        },\n      }}\n    />\n  </Tab>\n  <Tab value='api'>\n    TODO: Need a brief description of api steps. What do they do? What are they use for?\n    <DescriptionTable\n      type={{\n        path: {\n          description: 'The development server api path to expose your api step handler',\n          type: 'string',\n        },\n        method: {\n          description: 'The HTTP method to use for the development server api endpoint',\n          type: 'GET | POST',\n        },\n        bodySchema: {\n          description: 'This is only required for TS or JS steps that use zod for their http request body schema, this is used when processing the step to validate the request body before executing the step handler.',\n          type: 'string[]',\n        }\n      }} \n    />\n  </Tab>\n  <Tab value='cron'>\n    TODO: Need a brief description of cron steps. What do they do? What are they use for?\n    <DescriptionTable\n      type={{\n        cron: {\n          description: 'The cron schedule expression for your step',\n          type: 'string',\n        },\n      }} \n    />\n  </Tab>\n</Tabs>\n\n<Tabs  items={['TS', 'JS', 'Python', 'Ruby']}>\n  <Tab value=\"TS\">\n    TODO: we were going to break this up into sections instead of having them scroll?\n    ```typescript\n      // Event Step\n\n      import { z } from 'zod'\n\n      type Input = typeof inputSchema\n\n      const inputSchema = z.object({})\n\n      export const config: EventConfig<Input> = {\n        type: 'event',\n        name: 'stepA',\n        description: 'Hello from Step A',\n        subscribes: ['pms.start'],\n        emits: ['pms.stepA.done'],\n        input: inputSchema,\n        flows: ['parallel-merge'],\n      }\n\n      // Api step\n\n      import { z } from 'zod'\n\n      const inputSchema = z.object({})\n\n      export const config: ApiRouteConfig = {\n        type: 'api',\n        name: 'Test state api trigger',\n        description: 'test state',\n        path: '/test-state',\n        method: 'POST',\n        emits: ['test-state'],\n        bodySchema: inputSchema,\n        flows: ['test-state'],\n      }\n\n      // Cron step\n\n      export const config = {\n        type: 'cron' as const,\n        name: 'PeriodicJob',\n        description: 'Runs every minute and emits a timestamp',\n        cron: '0 * * * *', // run every hour at minute 0\n        emits: ['cron-ticked'],\n        flows: ['cron-example'],\n      }\n    ```\n  </Tab>\n  <Tab value=\"JS\">\n    ```javascript\n    // Event Step\n\n    const z = require('zod');\n\n    const inputSchema = z.object({});\n\n    const eventConfig = {\n      type: 'event',\n      name: 'stepA',\n      description: 'Hello from Step A',\n      subscribes: ['pms.start'],\n      emits: ['pms.stepA.done'],\n      input: inputSchema,\n      flows: ['parallel-merge'],\n    };\n\n    // Api step\n\n    const apiInputSchema = z.object({});\n\n    const apiConfig = {\n      type: 'api',\n      name: 'Test state api trigger',\n      description: 'test state',\n      path: '/test-state',\n      method: 'POST',\n      emits: ['test-state'],\n      bodySchema: apiInputSchema,\n      flows: ['test-state'],\n    };\n\n    // Cron step\n\n    const cronConfig = {\n      type: 'cron',\n      name: 'PeriodicJob',\n      description: 'Runs every minute and emits a timestamp',\n      cron: '0 * * * *', // run every hour at minute 0\n      emits: ['cron-ticked'],\n      flows: ['cron-example'],\n    };\n    ```\n  </Tab>\n  <Tab value=\"Python\">\n  ```python\n    # Event Step\n\n    config = {\n        \"type\": \"event\",\n        \"name\": \"Call OpenAI\",\n        \"subscribes\": [\"call-openai\"], \n        \"emits\": [\"openai-response\"],\n        \"input\": None,  # No schema validation in Python version\n        \"flows\": [\"openai\"]\n    }\n\n    # Cron Step\n\n    config = {\n        \"type\": \"cron\",\n        \"name\": \"PeriodicJob\",\n        \"description\": \"Runs every minute and emits a timestamp\",\n        \"cron\": \"0 * * * *\",\n        \"emits\": [\"cron-ticked\"],\n        \"flows\": [\"cron-example\"]\n    }\n  ```\n  </Tab>\n  <Tab value=\"Ruby\">\n  ```ruby\n    # Event Step\n\n    class Config\n      attr_reader :type, :name, :subscribes, :emits, :input, :flows\n\n      def initialize\n        @type = \"event\"\n        @name = \"Call OpenAI\"\n        @subscribes = [\"call-openai\"]\n        @emits = [\"openai-response\"]\n        @input = nil # No schema validation\n        @flows = [\"openai\"]\n      end\n    end\n\n    config = Config.new\n\n    # Cron Step\n\n    class Config\n      attr_reader :type, :name, :subscribes, :emits, :input, :flows\n\n      def initialize\n        @type = \"cron\"\n        @name = \"PeriodicJob\"\n        @description = \"Runs every minute and emits a timestamp\"\n        @cron = \"0 * * * *\"\n        @emits = [\"cron-ticked\"]\n        @flows = [\"cron-example\"]\n      end\n    end\n\n    config = Config.new\n  ```\n  </Tab>\n</Tabs>\n\n## Handler\n\nA **handler** function that processes an optional input and can **emit** new events. Handlers are executed when their subscribed topics are emitted. The handler receives the input data and a context object containing utilities like emit, state management, and logging.\n\n<Tabs  items={['TS', 'JS', 'Python', 'Ruby']}>\n  <Tab value='TS'>\n    ```typescript\n    import { FlowContext } from '@motiadev/core'\n\n    // ... step config\n\n    export const handler: StepHandler<typeof config> = async (input, { emit, traceId, state, logger }: FlowContext) => {\n      // emit: Function to emit new events\n      // traceId: Unique identifier for tracing the flow execution\n      // state: Access to state management\n      // logger: Structured logging utility\n    }\n    ```\n  </Tab>\n  <Tab value='JS'>\n    ```javascript\n    // ... step config\n\n    const handler = async (input, { emit, traceId, state, logger }) => {\n      // ... do some logic here\n    }\n\n    module.exports = {config, handler}\n    ```\n  </Tab>\n  <Tab value='Python'>\n    ```python\n    async def handler(args, ctx):\n        # ... do some logic here\n    ```\n  </Tab>\n  <Tab value='Ruby'>\n  ```ruby\n    def handler(args, ctx)\n        # ... do some logic here\n    end\n    ```\n  </Tab>\n</Tabs>\n\n<Callout>\nFollow the **[quick start](/docs/quick-start)** guide if you haven't set up Motia yet.\n</Callout>\n\n\n---\n\n---\n# File: docs/core/flows-and-visualization.mdx\n\n---\nsidebar_position: 9\ntitle: Flows & Visualization\n---\n\n**Flows** let you group multiple **steps** under a single name, making it easier to visually map out how events move across your application. While flows are technically optional, they're invaluable for:\n\n- **Clarity**: Understand how **steps** interact with each other at a glance\n- **Visualization**: Get a visual representation of event flow across your **steps**\n- **Observability**: Group logs and events by flow name for easier debugging\n\n<Steps>\n  <Step>\n  ### Tagging Steps with a Flow\n\n  To associate Steps with a flow, add a `flows` field to your Step config. For example:\n\n  ```js\n  // addNumbers.step.js\n  exports.config = {\n    type: 'event',\n    name: 'AddNumbers',\n    subscribes: ['add-numbers'],\n    emits: ['numbers-added'],\n    flows: ['demo-flow'], // <-- Assign it to a flow\n  }\n\n  // ... handler definition\n  ```\n\n  ```js\n  // exampleApi.step.js\n  exports.config = {\n    type: 'api',\n    name: 'AddNumbersApi',\n    path: '/api/add',\n    method: 'POST',\n    emits: ['add-numbers'],\n    flows: ['demo-flow'], // <-- Same flow name\n  }\n\n  // ... handler definition\n  ```\n\n  <Callout>You can associate a **step** with multiple flows by providing an array of flow names, for example: `['billing-flow', 'analytics-flow']`</Callout>\n  </Step>\n  <Step>\n  ### Visualizing Your Flows\n\n  <Steps>\n    <Step>\n      Start your development server:\n\n      <Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>\n        <Tab value='pnpm'>\n        ```bash\n        pnpm run dev\n        ```\n        </Tab>\n        <Tab value='yarn'>\n        ```bash\n        yarn run dev\n        ```\n        </Tab>\n        <Tab value='npm'>\n        ```bash\n        npm run dev\n        ```\n        </Tab>\n        <Tab value='bun'>\n        ```bash\n        bun run dev\n        ```\n        </Tab>\n      </Tabs>\n    </Step>\n    <Step>\n      [Open](http://localhost:3000) Motia Workbench in your browser (typically at `http://localhost:3000` or `http://127.0.0.1:3000`).\n    </Step>\n    <Step>\n      **Navigate** to your flow name on the left sidebar and click it. You'll see a visual graph where each **step** is represented as a node, with connecting lines showing event flow patterns.\n    </Step>\n    <Step>\n      **Click** on any **step** node to inspect its configuration details, including name, emits, subscribes, and other properties.\n    </Step>\n  </Steps>\n\n  ![Flow Visualization in Workbench](./../img/demo-workbench.png)\n  </Step>\n  <Step>\n    ### Flow Diagram Basics\n\n    Motia Workbench visualizes your application as an interactive node graph:\n\n    - **Steps** are displayed as nodes that subscribe to and emit events\n    - **Edges** (connecting lines) show event flow between steps\n    - The top-right corner contains a legend - hover over any item to highlight corresponding step types or edge types in the diagram\n  </Step>\n  <Step>\n    ### Flow-Specific Logs\n\n    In your terminal (or in the logs panel of **Motia Workbench**), all event activities performed by **steps** are logged and grouped by `traceId`. This makes it easy to trace and debug event flows through your application.\n  </Step>\n</Steps>\n\n<Callout>\nNew to Motia? Follow the **[quick start](/docs/quick-start)** guide to get set up.\n</Callout>\n\n---\n\n---\n# File: docs/core/logging.mdx\n\n---\nsidebar_position: 5\ntitle: Logging\n---\n\n## Overview\n\nMotia provides a powerful logging system that works across different runtime environments. The logging system:\n\nTODO: We need to describe somewhere in this document where the logs show up. In the console and workbench?\n\n- Provides real-time log streaming\n- Supports multiple log levels\n- Includes contextual information\n- Integrates with Motia Workbench\n\n## Core Concepts\n\n### Log Levels\n\nMotia supports four standard log levels:\n\n| Log Type | Description |\n| -------- | ----------- |\n| info     | General information about step execution, workflow progress, and successful operations |\n| error    | Critical issues, exceptions, failed operations, and system errors |\n| debug    | Detailed debugging information and diagnostic data for troubleshooting |\n| warn     | Potential issues, edge cases, or situations requiring attention |\n\n### Log Context\n\nEach log entry automatically includes:\n\n<DescriptionTable\n  type={{\n    timestamp: {\n      description: 'When the log was generated',\n      type: 'string',\n    },\n    traceId: {\n      description: 'Unique identifier for the workflow execution',\n      type: 'string',\n    },\n    flows: {\n      description: 'Array of flow names this step belongs to',\n      type: 'string[]',\n    },\n    file: {\n      description: 'Source file generating the log',\n      type: 'string',\n    },\n    level: {\n      description: 'Log level',\n      type: 'string',\n    },\n    msg: {\n      description: 'Log message',\n      type: 'string',\n    },\n  }}\n/>\n\n\n## Using Logging in Steps\n\n### TypeScript/JavaScript\n\n<Tabs items={['TS', 'JS', 'Python', 'Ruby']}>\n  <Tab value='TS'>\n    ```typescript\n    import { EventConfig, StepHandler } from '@motiadev/core'\n\n    export const handler: StepHandler<typeof config> = async (input, { logger }) => {\n      // Basic logging\n      logger.info('Starting payment processing')\n\n      // Logging with context and structured data\n      logger.info('Payment processed successfully', {\n        amount: input.amount,\n        currency: input.currency,\n      })\n\n      // Error logging with enhanced context\n      try {\n        await processPayment(input)\n      } catch (error) {\n        logger.error('Payment processing failed', {\n          error: error.message,\n          code: error.code,\n          stack: error.stack,\n          input: JSON.stringify(input)\n        })\n      }\n\n      // Debug logging with enhanced details\n      logger.debug('Payment processing details', {\n        rawInput: input,\n        timestamp: Date.now(),\n      })\n\n      // Warning logging with thresholds\n      if (input.amount > 10000) {\n        logger.warn('Large payment amount detected', {\n          amount: input.amount,\n          threshold: 10000,\n          currency: input.currency\n        })\n      }\n    }\n    ```\n  </Tab>\n  <Tab value='JS'>\n    ```javascript\n    export const handler = async (input, { logger }) => {\n      // Basic logging\n      logger.info('Processing payment')\n\n      // Logging with context\n      logger.info('Payment processed', {\n        amount: input.amount,\n        currency: input.currency,\n      })\n\n      // Error logging\n      try {\n        await processPayment(input)\n      } catch (error) {\n        logger.error('Payment failed', {\n          error: error.message,\n          code: error.code,\n        })\n      }\n\n      // Debug logging\n      logger.debug('Payment details', {\n        rawInput: input,\n        timestamp: Date.now(),\n      })\n\n      // Warning logging\n      if (input.amount > 10000) {\n        logger.warn('Large payment detected', {\n          amount: input.amount,\n        })\n      }\n    }\n    ```\n  </Tab>\n  <Tab value='Python'>\n    ```python\n    async def handler(input, ctx):\n        # Basic logging\n        ctx.logger.info('Processing payment')\n\n        # Logging with context\n        ctx.logger.info('Payment processed', {\n            'amount': input.amount,\n            'currency': input.currency\n        })\n\n        # Error logging\n        try:\n            await process_payment(input)\n        except Exception as error:\n            ctx.logger.error('Payment failed', {\n                'error': str(error)\n            })\n\n        # Debug logging\n        ctx.logger.debug('Payment details', {\n            'raw_input': input.__dict__,\n            'timestamp': time.time()\n        })\n    ```\n  </Tab>\n  <Tab value='Ruby'>\n    ```ruby\n    def handler(input, ctx)\n      # Basic logging\n      ctx.logger.info('Processing payment')\n\n      # Logging with context\n      ctx.logger.info('Payment processed', {\n        amount: input.amount,\n        currency: input.currency\n      })\n\n      # Error logging\n      begin\n        process_payment(input)\n      rescue StandardError => error\n        ctx.logger.error('Payment failed', {\n          error: error.message\n        })\n      end\n\n      # Debug logging\n      ctx.logger.debug('Payment details', {\n        raw_input: input.to_h,\n        timestamp: Time.now.to_i\n      })\n    end\n    ```\n  </Tab>\n</Tabs>\n\n## Best Practices\n\n### Consistent Log Levels\n\n<Tabs items={['info', 'error', 'debug', 'warn']}>\n  <Tab value='info'>\n  **Use `info` for**:\n  \n  - Step start/completion\n  - Important business events\n  - State changes\n  - Successful operations\n  - Key workflow transitions\n  - API calls and responses\n  - Data transformations\n  </Tab>\n  <Tab value='error'>\n  **Use `error` for**:\n  \n  - Exceptions\n  - API failures\n  - Business rule violations\n  - Data integrity issues\n  - Security violations\n  - System resource exhaustion\n  - Critical configuration issues\n  </Tab>\n  <Tab value='debug'>\n  **Use `debug` for**:\n  \n  - Detailed execution data\n  - Input/output values\n  - Performance metrics\n  </Tab>\n  <Tab value='warn'>\n  **Use `warn` for**:\n  \n  - Potential issues\n  - Deprecated features\n  - Resource warnings\n  </Tab>\n</Tabs>\n\n### Structured Logging\n\n```typescript\n// Good - Structured and searchable\nlogger.info('Payment processed', {\n  paymentId: '123',\n  amount: 100,\n  status: 'success',\n})\n\n// Avoid - Harder to parse and search\nlogger.info(`Payment ${paymentId} processed: amount=${amount}`)\n```\n\n### Context Propagation\n\n```typescript\nexport const handler: StepHandler<typeof config> = async (input, { logger, traceId }) => {\n  // Add business context\n  logger.info('Starting payment processing', {\n    businessUnit: input.businessUnit,\n    region: input.region,\n    correlationId: input.correlationId,\n  })\n\n  try {\n    const result = await processPayment(input)\n\n    // Log success with result context\n    logger.info('Payment successful', {\n      transactionId: result.transactionId,\n      processingTime: result.duration,\n    })\n  } catch (error) {\n    // Log error with full context\n    logger.error('Payment failed', {\n      error: error.message,\n      code: error.code,\n      attempt: error.attempt,\n      failureType: error.type,\n    })\n  }\n}\n```\n\n### Performance Logging\n\n```typescript\nexport const handler: StepHandler<typeof config> = async (input, { logger }) => {\n  const startTime = performance.now()\n\n  // Process payment\n  const result = await processPayment(input)\n\n  // Log performance metrics\n  logger.info('Payment processing completed', {\n    duration: performance.now() - startTime,\n    steps: result.steps.length,\n    dataSize: JSON.stringify(input).length,\n    memoryUsage: process.memoryUsage().heapUsed,\n    timestamp: new Date().toISOString()\n  })\n}\n```\n\n## Debugging\n\n### Log Filtering\n\nMotia Workbench provides powerful log filtering capabilities:\n\n- Filter by log level\n- Filter by flow\n- Filter by time range\n- Search by content\n\n### Common Patterns\n\n1. **Transaction Tracing**\n\n```typescript\nlogger.info('Starting transaction', {\n  type: 'START',\n  transactionId,\n})\n\n// ... processing ...\n\nlogger.info('Transaction complete', {\n  type: 'END',\n  transactionId,\n  duration,\n})\n```\n\n2. **Error Correlation**\n\n```typescript\ntry {\n  await riskyOperation()\n} catch (error) {\n  logger.error('Operation failed', {\n    error: error.message,\n    stack: error.stack,\n    correlationId: input.correlationId,\n  })\n}\n```\n\n## Monitoring\n\n### Metrics to Track\n\n- Log volume by level\n- Error rates and patterns\n- Warning frequencies\n- Performance metrics\n- Resource utilization\n- Business metrics\n\n### Log Analysis\n\n```typescript\n// Track error rates\nlogger.error('API failure', {\n  endpoint: '/api/payment',\n  statusCode: 500,\n  retryCount: 3,\n  errorType: 'TIMEOUT',\n  latency: 5000,\n  region: 'us-west-2'\n})\n\n// Monitor performance\nlogger.info('Operation complete', {\n  operationType: 'payment',\n  duration: 1500,\n  resourceUsage: {\n    memory: process.memoryUsage(),\n    cpu: process.cpuUsage(),\n  },\n  timestamp: new Date().toISOString(),\n  environment: process.env.NODE_ENV\n})\n```\n\n\n---\n\n---\n# File: docs/core/running-and-debugging.mdx\n\n---\nsidebar_position: 4\ntitle: Running & Debugging\n---\n\nIf you setup your Motia project with the **default** template, you will see the following **steps** in your project:\n\n<Tabs items={['api.step.ts', 'one.step.ts', 'two.step.ts']}>\n  <Tab value='api.step.ts'>\n  ```typescript\n  // api.step.ts\n  import { ApiRouteConfig, StepHandler } from '@motiadev/core'\n  import { z } from 'zod'\n\n  const inputSchema = z.object({})\n\n  export const config: ApiRouteConfig = {\n    type: 'api',\n    name: 'default flow api trigger',\n    description: 'default template api trigger',\n    path: '/default',\n    method: 'POST',\n    emits: ['test-state'],\n    bodySchema: inputSchema,\n    flows: ['default'],\n  }\n\n  export const handler: StepHandler<typeof config> = async (req, { logger, emit }) => {\n    logger.info('processing default flow api step', req)\n\n    await emit({\n      type: 'test-state',\n      data: {},\n    })\n\n    return {\n      status: 200,\n      body: { message: 'test-state topic emitted' },\n    }\n  }\n  ```\n  </Tab>\n  <Tab value='one.step.ts'>\n  ```typescript\n  // one.step.ts\n  import { EventConfig, StepHandler } from '@motiadev/core'\n  import { z } from 'zod'\n  import equal from 'deep-equal'\n\n  type Input = typeof inputSchema\n\n  const inputSchema = z.object({})\n\n  export const config: EventConfig<Input> = {\n    type: 'event',\n    name: 'Set state change',\n    description: 'set a state change for evaluation',\n    subscribes: ['test-state'],\n    emits: ['check-state-change'],\n    input: inputSchema,\n    flows: ['default'],\n  }\n\n  export const handler: StepHandler<typeof config> = async (input, { traceId, logger, state, emit }) => {\n    logger.info('step one, set a value in state')\n\n    const message = 'welcome to motia!';\n    await state.set<any>(traceId, 'test', message)\n\n    await emit({\n      type: 'check-state-change',\n      data: {key: 'test', expected: message}\n    })\n  }\n  ```\n  </Tab>\n  <Tab value='two.step.ts'>\n  ```typescript\n  // two.step.ts\n  import { EventConfig, StepHandler } from '@motiadev/core'\n  import { z } from 'zod'\n  import equal from 'deep-equal'\n\n  type Input = typeof inputSchema\n\n  const inputSchema = z.object({\n    key: z.string(),\n    expected: z.optional(z.unknown()),\n  })\n\n  export const config: EventConfig<Input> = {\n    type: 'event',\n    name: 'Check state change',\n    description: 'check state change',\n    subscribes: ['check-state-change'],\n    emits: [],\n    input: inputSchema,\n    flows: ['default'],\n  }\n\n  export const handler: StepHandler<typeof config> = async (input, { traceId, logger, state }) => {\n    logger.info('received check-state-change event', input)\n\n    const value = await state.get<any>(traceId, input.key)\n\n    if (value !== input.expected) {\n      logger.error(`🔴 the provided  value for the state key ${input.key} does not match`, { value, expected: input.expected })\n    } else {\n      logger.info(`🟢 the provided value matches the state value for key ${input.key} 🏁`)\n    }\n  }\n  ```\n  </Tab>\n</Tabs>\n\nHere’s how to **run** and **debug** these Steps locally:\n\n<Steps>\n  <Step>\n  ### 1. Start the Dev Server\n\n  1. Open a terminal and navigate to your **Motia** project root folder\n  2. Run the following command to initialize the Motia development server:\n\n  <Tabs items={['pnpm', 'yarn', 'npm', 'bun']}>\n    <Tab value='pnpm'>\n    ```bash\n    pnpm run dev\n    ```\n    </Tab>\n    <Tab value='yarn'>\n    ```bash\n    yarn run dev\n    ```\n    </Tab>\n    <Tab value='npm'>\n    ```bash\n    npm run dev\n    ```\n    </Tab>\n    <Tab value='bun'>\n    ```bash\n    bun run dev\n    ```\n    </Tab>\n  </Tabs>\n  3. You can [open](http://localhost:3000) Motia Workbench, select the **default** flow from the left side bar\n  4. Expand the logs container\n\n  ![Logs in Motia Workbench](./../img/logs.png)\n  </Step>\n  <Step>\n  ### Trigger the API Step\n\n  Run the following command to emit an event to the **default** flow:\n\n  <Tabs items={['cli', 'curl']}>\n    <Tab value='cli'>\n    ```bash\n    npx motia emit --topic test-state --message '{}'\n    ```\n    </Tab>\n    <Tab value='curl'>\n    ```bash\n    curl -X POST http://localhost:3001/default \\\n     -H \"Content-Type: application/json\" \\\n     -d '{}'\n    ```\n    </Tab>\n  </Tabs>\n  </Step>\n  <Step>\n  ### Checking Logs\n\n  After emitting the event, you should see the logs in the logs container\n\n  ![Logs in Motia Workbench](./../img/logs.png)\n\n  <Callout>If something fails, watch for error logs or stack traces. You can add `logger.info()`, `logger.error()`, etc., in your handlers for more detail.</Callout>\n  </Step>\n  <Step>\n  ### Stopping the development server\n\n  Press **Ctrl + C** (or **Cmd + C** on macOS) in your terminal. That’s it!\n  </Step>\n</Steps>\n\n\n---\n\n---\n# File: docs/core/state-management.md\n\n---\nsidebar_position: 6\ntitle: State Management\n---\n\nMotia provides a robust state management system for maintaining workflow state across steps. The system:\n\nTODO: I thought this was defaulting to file based, not redis?\n- Is distributed by default using Redis \n- Supports atomic operations\n- Provides TTL-based cleanup\n- Maintains state isolation between flows\n\n## Core Concepts\n\n### State Scope\n\nEach workflow execution gets a unique state space identified by its `traceId`. This ensures:\n\n- Isolation between concurrent executions\n- Clean state boundaries\n- Automatic cleanup\n\n### State Structure\n\n```typescript\n// Example state structure\n{\n  \"motia:state:{traceId}\": {\n    \"booking\": {\n      \"customer\": { ... },\n      \"venue\": { ... }\n    },\n    \"payment\": {\n      \"status\": \"pending\",\n      \"amount\": 100\n    }\n  }\n}\n```\n\n## Using State in Steps\n\n### TypeScript/JavaScript\nTODO: These should be the tabbed based component right? To be consistent with other pages?\n```typescript\nimport { EventConfig, StepHandler } from '@motiadev/core'\n\nexport const handler: StepHandler<typeof config> = async (input, { state, traceId }) => {\n  // Store state\n  await state.set(traceId, 'booking', {\n    customer: input.customer,\n    venue: input.venue,\n  })\n\n  // Retrieve state\n  const booking = await state.get<BookingData>(traceId, 'booking')\n\n  // Delete specific state\n  await state.delete(traceId, 'booking')\n\n  // Clear all state for this trace\n  await state.clear(traceId)\n}\n```\n\n### Python\n\n```python\nasync def handler(input, ctx):\n    # Store state\n    await ctx.state.set('booking', {\n        'customer': input.customer,\n        'venue': input.venue\n    })\n\n    # Retrieve state\n    booking = await ctx.state.get('booking')\n\n    # Delete specific state\n    await ctx.state.delete('booking')\n\n    # Clear all state\n    await ctx.state.clear()\n```\n\n### Ruby\n\n```ruby\ndef handler(input, ctx)\n  # Store state\n  ctx.state.set('booking', {\n    customer: input.customer,\n    venue: input.venue\n  })\n\n  # Retrieve state\n  booking = ctx.state.get('booking')\n\n  # Delete specific state\n  ctx.state.delete('booking')\n\n  # Clear all state\n  ctx.state.clear()\nend\n```\n\n## Configuration\n\n### Redis Adapter\n\n```yaml\n# config.yml\nstate:\n  adapter: redis\n  host: localhost\n  port: 6379\n  password: optional\n  ttl: 3600 # Optional: Time in seconds before state expires\n```\n\n### Custom State Adapters\n\n```typescript\nimport { StateAdapter } from '@motiadev/core'\n\nclass CustomStateAdapter extends StateAdapter {\n  async get<T>(traceId: string, key: string): Promise<T | null> {\n    // Implementation\n  }\n\n  async set<T>(traceId: string, key: string, value: T): Promise<void> {\n    // Implementation\n  }\n\n  async delete(traceId: string, key: string): Promise<void> {\n    // Implementation\n  }\n\n  async clear(traceId: string): Promise<void> {\n    // Implementation\n  }\n\n  async cleanup(): Promise<void> {\n    // Implementation\n  }\n}\n```\n\n## Best Practices\n\n### State Organization\n\n1. **Use Namespacing**\n\n   ```typescript\n   // Good\n   await state.set(traceId, 'booking.customer', customerData)\n   await state.set(traceId, 'booking.venue', venueData)\n\n   // Avoid\n   await state.set(traceId, 'customer', customerData)\n   await state.set(traceId, 'venue', venueData)\n   ```\n\n2. **Type Safety**\n\n   ```typescript\n   // Define types for your state\n   interface BookingState {\n     customer: CustomerData\n     venue: VenueData\n     status: 'pending' | 'confirmed'\n   }\n\n   // Use typed state access\n   const booking = await state.get<BookingState>(traceId, 'booking')\n   ```\n\n3. **State Cleanup**\n\n   ```typescript\n   // Clean up after flow completion\n   export const handler: StepHandler<typeof config> = async (input, { state, traceId }) => {\n     try {\n       // Process final step\n       await processFinalization(input)\n\n       // Clean up state\n       await state.clear(traceId)\n     } catch (error) {\n       // Handle errors\n     }\n   }\n   ```\n\n### Performance Considerations\n\n1. **Batch Operations**\n\n   - Group related state updates\n   - Use atomic operations when possible\n   - Consider state size and access patterns\n\n2. **TTL Management**\n   - Set appropriate TTLs for your workflow\n   - Consider workflow duration\n   - Account for error recovery time\n\n## Debugging\n\n### Redis CLI Commands\n\n```bash\n# List all state keys\nredis-cli KEYS \"motia:state:*\"\n\n# Get specific state\nredis-cli GET \"motia:state:{traceId}:booking\"\n\n# Check TTL\nredis-cli TTL \"motia:state:{traceId}\"\n```\n\n### Common Issues\nTODO: This section is weak. Either need to make it much more robust or remove it\n1. **State Not Found**\n\n   - Check TTL expiration\n   - Verify traceId\n   - Check key namespacing\n\n2. **Concurrent Access**\n\n   - Use atomic operations\n   - Implement retry logic\n   - Handle race conditions\n\n3. **Memory Usage**\n   - Monitor Redis memory\n   - Implement state cleanup\n   - Use appropriate TTLs\n\n\n---\n\n---\n# File: docs/examples/tldr-show-me-something-cool.md\n\n---\nsidebar_position: 10\ntitle: Show Me Something Cool\n---\n\n# Skip the Boring Stuff\n\n## A Real-World Multi-Step OpenAI “Sentiment Analysis” Example\n\nSometimes you don’t just want a **simple** “prompt => response.” Instead, you want the LLM to decide how to proceed. Below is a minimal example that:\n\n1. Receives user input via `POST /api/analyze-sentiment`.\n2. Calls OpenAI and **instructs** the LLM to return JSON with a `sentiment` field.\n3. Parses that JSON and **emits** different events depending on whether `sentiment` is `\"positive\"` or `\"negative\"` (or anything else).\n4. Two specialized responders handle each sentiment separately.\n\n---\n\n## The Steps\n\n```ts\n// steps/analyzeSentimentApi.step.ts\n// Receives user text, emits \"openai.analyzeSentimentRequest\".\nimport { ApiRouteConfig, StepHandler } from 'wistro'\nimport { z } from 'zod'\n\nexport const config: ApiRouteConfig = {\n  type: 'api',\n  name: 'Analyze Sentiment (API)',\n  path: '/api/analyze-sentiment',\n  method: 'POST',\n  emits: ['openai.analyzeSentimentRequest'],\n  bodySchema: z.object({\n    text: z.string().min(1, 'text is required'),\n  }),\n  flows: ['sentiment-demo'],\n}\n\nexport const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {\n  const { text } = req.body\n\n  logger.info('[AnalyzeSentimentAPI] Received text', { text })\n\n  // Emit an event to call OpenAI\n  await emit({\n    type: 'openai.analyzeSentimentRequest',\n    data: { text },\n  })\n\n  // Return right away\n  return {\n    status: 200,\n    body: { status: 'Accepted', message: 'Your text is being analyzed' },\n  }\n}\n```\n\n```ts\n// steps/openAiAnalyzeSentiment.step.ts\n// Calls OpenAI, instructing it to ONLY return JSON like {\"sentiment\":\"positive\",\"analysis\":\"...\"}\nimport { EventConfig, StepHandler } from 'wistro'\nimport { z } from 'zod'\nimport { OpenAI } from 'openai'\n\n// 1) Create an OpenAI client (newer syntax)\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })\n\n// 2) Define the input schema for your step\nconst inputSchema = z.object({\n  text: z.string(),\n})\n\nexport const config: EventConfig<typeof inputSchema> = {\n  type: 'event',\n  name: 'OpenAI Sentiment Analyzer',\n  subscribes: ['openai.analyzeSentimentRequest'],\n  // We'll emit different events: \"openai.positiveSentiment\" or \"openai.negativeSentiment\"\n  emits: ['openai.positiveSentiment', 'openai.negativeSentiment'],\n  input: inputSchema,\n  flows: ['sentiment-demo'],\n}\n\n// 3) Provide the code that runs on each event\nexport const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {\n  logger.info('[OpenAI Sentiment Analyzer] Prompting OpenAI...', { text: input.text })\n\n  try {\n    // We'll ask the model to ONLY return JSON with a \"sentiment\" field\n    const systemPrompt =\n      'You are an assistant that returns only JSON: {\"sentiment\":\"positive|negative\",\"analysis\":\"...\"}'\n    const userPrompt = `Analyze the sentiment of this text: \"${input.text}\". Return JSON with keys \"sentiment\" and \"analysis\".`\n\n    // 4) Use the new openai syntax:\n    const response = await openai.chat.completions.create({\n      model: 'gpt-3.5-turbo',\n      messages: [\n        { role: 'system', content: systemPrompt },\n        { role: 'user', content: userPrompt },\n      ],\n    })\n\n    // 5) Log and parse the response\n    const content = response.choices[0]?.message?.content || ''\n    logger.info('[OpenAI Sentiment Analyzer] Raw response', { content })\n\n    let parsed: { sentiment?: string; analysis?: string } = {}\n    try {\n      parsed = JSON.parse(content.trim())\n    } catch (err) {\n      logger.error('[OpenAI Sentiment Analyzer] Unable to parse JSON', { error: err })\n      // If it's not JSON, we bail or handle differently\n      return\n    }\n\n    // 6) Decide how to route the event\n    if (parsed.sentiment?.toLowerCase() === 'positive') {\n      await emit({\n        type: 'openai.positiveSentiment',\n        data: { ...parsed },\n      })\n    } else {\n      // default to negative\n      await emit({\n        type: 'openai.negativeSentiment',\n        data: { ...parsed },\n      })\n    }\n  } catch (err: any) {\n    logger.error('[OpenAI Sentiment Analyzer] Error calling OpenAI', { error: err.message })\n  }\n}\n```\n\n```ts\n// steps/handlePositive.step.ts\n// Handles \"openai.positiveSentiment\"\nimport { EventConfig, StepHandler } from 'wistro'\nimport { z } from 'zod'\n\nconst positiveSchema = z.object({\n  sentiment: z.string(),\n  analysis: z.string().optional(),\n})\n\nexport const config: EventConfig<typeof positiveSchema> = {\n  type: 'event',\n  name: 'Positive Sentiment Responder',\n  subscribes: ['openai.positiveSentiment'],\n  emits: [],\n  input: positiveSchema,\n  flows: ['sentiment-demo'],\n}\n\nexport const handler: StepHandler<typeof config> = async (input, { logger }) => {\n  logger.info('[Positive Responder] The sentiment is positive!', { analysis: input.analysis })\n  // Maybe notify a Slack channel: \"All good vibes here!\"\n}\n```\n\n```ts\n// steps/handleNegative.step.ts\n// Handles \"openai.negativeSentiment\"\nimport { EventConfig, StepHandler } from 'wistro'\nimport { z } from 'zod'\n\nconst negativeSchema = z.object({\n  sentiment: z.string(),\n  analysis: z.string().optional(),\n})\n\nexport const config: EventConfig<typeof negativeSchema> = {\n  type: 'event',\n  name: 'Negative Sentiment Responder',\n  subscribes: ['openai.negativeSentiment'],\n  emits: [],\n  input: negativeSchema,\n  flows: ['sentiment-demo'],\n}\n\nexport const handler: StepHandler<typeof config> = async (input, { logger }) => {\n  logger.info('[Negative Responder] The sentiment is negative or unknown.', { analysis: input.analysis })\n  // Could escalate to a service, or respond gently, etc.\n}\n```\n\n---\n\n## Visual Overview\n\nHere’s how the events chain together:\n\n![Flow: Sentiment Analysis Steps](./../img/sentiment-analyzer.jpg)\n\n1. **Analyze Sentiment (API)** => emits `openai.analyzeSentimentRequest`\n2. **OpenAI Sentiment Analyzer** => calls OpenAI, parses JSON =>\n   - If `sentiment: \"positive\"` => emits `openai.positiveSentiment`\n   - Else => emits `openai.negativeSentiment`\n3. **Positive Sentiment Responder** or **Negative Sentiment Responder**\n\n---\n\n## Trying It Out\n\n1. **Install** dependencies (`wistro` + `openai`):\n\n   ```shell\n   pnpm install wistro openai\n   ```\n\n2. **Create** your `steps/` directory and add the five `.step.ts` files:\n\n   - `analyzeSentimentApi.step.ts`\n   - `openAiAnalyzeSentiment.step.ts`\n   - `handlePositive.step.ts`\n   - `handleNegative.step.ts`\n\n3. **Set** your `OPENAI_API_KEY`:\n\n   ```shell\n   export OPENAI_API_KEY=\"sk-...\"\n   ```\n\n4. **Run** your project (e.g.):\n\n   ```shell\n   pnpm wistro dev\n   ```\n\n5. **Send** text to the API:\n\n   ```shell\n   curl -X POST http://localhost:3000/api/analyze-sentiment \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"text\":\"I absolutely love this new device!\"}'\n   ```\n\n   - Check logs. You should see either the `[Positive Responder]` or `[Negative Responder]` step firing, depending on the LLM’s JSON output.\n\n6. **Extend**:\n   - Tweak the system instructions to force certain outputs or include more details.\n   - Create more specialized responders (like “neutralSentiment”).\n   - Integrate a notification step (Slack, database, etc.).\n\nTry it out, see the branching logic in action, and enjoy skipping all the boring boilerplate!\n\n\n---\n\n---\n# File: docs/index.mdx\n\n---\ntitle: Overview\n---\n\nMotia is a powerful framework for building event-driven workflows. It provides simple, composable building blocks called **Steps** that handle your business logic while Motia manages the infrastructure.\n\n## Installation\n\nCreate a new **Motia** project using the default template\n\n```bash\nnpx motia create -t default\n```\n\nor add **Motia** into an existing project\n\n```package-install\nmotia @motiadev/core @motiadev/workbench\n```\n\n## Why Motia?\n\n- 🚀 **Zero Infrastructure Setup** - No message queues or event brokers to configure\n- 🔌 **Plug-and-Play Steps** - Write code in your favorite language (JS, TS, Python, Ruby)\n- 📊 **Built-in Observability** - Real-time logs, traces, and flow visualization\n- ⚡ **Built-in API & Scheduling** - Out of the box support for HTTP endpoints and scheduled tasks\n\n## Core Concepts\n\n| Concept | Description |\n|---------|-------------|\n| **Steps** | Self-contained units of logic that process events |\n| **Flows** | Logical groupings of related steps |\n| **Events** | Messages passed between steps |\n| **Topics** | Named channels for event routing |\n\n## Ready to Build?\n\n1. Follow our [Quick Start](/docs/quick-start) guide to create your first Motia application\n2. Check out [Examples](/docs/examples) for common patterns and use cases\n3. Join our [Discord](https://discord.gg/motia) for real-time help\n\n## Built for Developers\n\nPerfect for building:\n- 🤖 Agentic workflows\n- 🔄 Data pipelines\n- 🌐 API integrations\n- ⚡ Real-time applications\n\n## Join the Community\n\n- 💬 [Discord](https://discord.gg/motia) - Get help and share ideas\n- 🐙 [GitHub](https://github.com/motiadev/motia) - Contribute or report issues\n- 🐦 [Twitter](https://twitter.com/motiadev) - Stay updated\n\n\n---\n\n---\n# File: docs/quick-start.mdx\n\n---\ntitle: Quick Start\n---\n\nThis guide shows how to define a **minimal [step](/docs/core/defining-steps)** and run the **Motia** dev server—using **pnpm** for package management.\n\n<Steps>\n<Step>\n### Setup your project\n\n<Tabs items={['Automated', 'Manual']}>\n  <Tab value=\"Automated\">\n    Use **npx**, this will create a new project in your current directory:\n\n    ```bash\n    npx motia create -t default\n    ```\n\n    If you wish to initialize the project in a separate folder add `-n <folder name>`\n\n    ```bash\n    npx motia create -t default -n my-project\n    ```\n\n    <Callout>\n      If you don't want to use the default template, you can remove the `-t default` portion, or see the list of available templates by executing `npx motia templates`\n    </Callout>\n\n    You should see the following files in your project:\n\n    <Files>\n      <Folder name=\"steps\" defaultOpen>\n        <File name=\"one.step.ts\" />\n        <File name=\"two.step.ts\" />\n        <File name=\"api.step.ts\" />\n      </Folder>\n      <File name=\"package.json\" />\n    </Files>\n  </Tab>\n  <Tab value=\"Manual\">\n    <Callout>For these instructions we recommend using `pnpm`, but you can use your preferred package manager (yarn, npm, etc.)</Callout>\n\n    Add the following dependencies to your project:\n    ```package-install\n    @motiadev/core @motiadev/workbench zod\n    ```\n\n    Add the following script to your **package.json** in order to initialize the development server and workbench:\n\n    ```json\n    {\n      \"scripts\": {\n        \"dev\": \"motia dev\"\n      }\n    }\n    ```\n\n    <Callout>If your steps will be developed using **TypeScript** or **vanilla JavaScript**, you will need Zod to define your step input schema</Callout>\n\n    If you want to use **TypeScript**, add the following dependencies:\n\n    ```package-install\n    ts-node typescript -D\n    ```\n\n    Create the steps folder\n\n    ```bash\n    mkdir steps\n    ```\n  </Tab>\n</Tabs>\n\n</Step>\n<Step>\n### Minimal Step Example\n\n<Callout>**Skip this step** if you used the automated project setup with a template</Callout>\n\nCreate a file named **addNumbers.step.js** in your project, **store it inside the steps folder**:\n\n<Files>\n  <Folder name=\"steps\" defaultOpen>\n    <File name=\"addNumbers.step.js\" />\n  </Folder>\n</Files>\n\n```js\nexports.config = {\n  type: 'event', // \"event\", \"api\", or \"cron\"\n  name: 'AddNumbers',\n  subscribes: ['add-numbers'],\n  emits: ['numbers-added'],\n  flows: ['numbers']\n}\n\nexports.handler = async (input, { emit }) => {\n  const sum = (input.a || 0) + (input.b || 0)\n  await emit({\n    type: 'numbers-added',\n    data: { result: sum },\n  })\n}\n```\n\nThis step **listens** for the event `\"add-numbers\"` and **emits** `\"numbers-added\"`.\nIt's the simplest possible example with **no** extra dependencies or logs.\n\n</Step>\n<Step>\n### Start Motia\n\nFrom your project root, run:\n\n```bash\npnpm run dev\n```\n\nMotia will:\n\n1. Scan for `.step.<py|ts|js|rb>` files inside the **steps** folder\n2. Register your Steps\n3. Launch a dev server (port **3000** by default)\n\n<Callout>You can change the port by passing the `--port` flag to the `dev` command</Callout>\n\n```bash\npnpm run dev --port 3001\n```\n</Step>\n<Step>\n### Test your step\n\nYou can test your step using the **Motia** CLI:\n\n<Tabs items={['cli', 'curl']}>\n  <Tab value='cli'>\n  If you used the automated project setup with the default template, you can test your step by emitting the following event:\n  ```bash\n  npx motia emit --topic test-state --message '{}'\n  ```\n\n  If you used the add number example, you can test your step by emitting the following event:\n  ```bash\n  npx motia emit --topic add-numbers --message '{\"a\": 5, \"b\": 3}'\n  ```\n  </Tab>\n  <Tab value='curl'>\n  If you used the automated project setup with the default template, you can test your step by emitting the following event:\n  ```bash\n  curl -X POST http://localhost:3001/default \\\n    -H \"Content-Type: application/json\" \\\n    -d '{}'\n  ```\n\n  <Callout type=\"warn\">You can't test the add number example using curl, you will need to use the CLI, using an api endpoint requires an api step.</Callout>\n  </Tab>\n</Tabs>\n\nMotia will:\n\n1. Emit a new event with the provided topic and message\n2. The event manager will detect the new event and match it against your registered step\n3. Execute your step with the provided input\n4. Log the journey of the event, including the emitted `numbers-added` event\n</Step>\n</Steps>\n\n\n---\n\n---\n# File: docs/workbench/motia-workbench.md\n\n---\nsidebar_position: 7\ntitle: Motia Workbench\n---\n\n# Motia Workbench\nTODO: Guessing we haven't worked on this yet?\nThe Motia Workbench is a development UI that helps you build, test, and debug your flows. It provides:\n\n- Visual flow diagrams\n- Real-time logs\n- Step visualization\n- Flow testing\n\n## Starting the Workbench\n\nRun Motia in development mode:\n\n```bash\npnpm dev\n```\n\nThis starts:\n\n- The Motia server\n- The Workbench UI (typically at http://localhost:3000)\n- File watching for hot reloading\n\n## Flow Visualization\n\nThe Workbench automatically creates visual diagrams of your flows, showing:\n\n- API Steps (as trigger nodes)\n- Event Steps (as processing nodes)\n- NoOp Steps (as external process nodes)\n- Event connections between steps\n\nEach step shows:\n\n- The step name\n- Events it subscribes to\n- Events it emits\n- API routes (for API steps)\n- Custom visualizations (if provided)\n\n## Logs Console\n\nThe log console shows real-time logs from your flows:\n\n- Log level (info, error, debug, warn)\n- Timestamp\n- Flow name\n- Step name\n- Custom log messages\n- Trace IDs\n\nExample log output:\n\n```\n[INFO] 2024-01-16 10:30:15 [payment-flow] Stripe Webhook: Payment received\n[ERROR] 2024-01-16 10:30:16 [payment-flow] Process Payment: Invalid amount\n```\n\n## Testing Flows\n\nThe Workbench makes it easy to test your flows:\n\n1. **API Testing**\n\n   - API endpoints are automatically exposed\n   - Use the OpenAPI documentation\n   - Test different payloads\n   - See real-time results\n\n2. **Event Monitoring**\n\n   - Watch events flow through the system\n   - Trace event paths\n   - Debug event payloads\n   - Monitor state changes\n\n3. **Custom Test UIs**\n   - Create test-specific visualizations\n   - Add interactive elements\n   - Show test progress\n   - Display test results\n\n## Flow Selection\n\nThe Workbench sidebar shows all available flows:\n\n- Grouped by category\n- Search functionality\n- Quick navigation\n- Flow metadata\n\n## Step Details\n\nClick any step to see its details:\n\n- Configuration\n- Event schemas\n- Documentation\n- Custom UI elements\n\n## Development Features\n\n1. **Hot Reloading**\n\n   - Changes reflect immediately\n   - No server restart needed\n   - Step updates in place\n   - UI refreshes automatically\n\n2. **Error Handling**\n\n   - Clear error messages\n   - Stack traces when needed\n   - Error highlighting\n   - Quick error fixes\n\n3. **State Management**\n   - Monitor Redis state\n   - Track event state\n   - Debug state issues\n   - Clear state when needed\n\n## Next Steps\n\n1. **Getting Started**\n\n   - Run the workbench\n   - Create a test flow\n   - Add custom visualizations\n   - Test your flow\n\n2. **Advanced Usage**\n\n   - Add complex flows\n   - Create test suites\n   - Monitor performance\n   - Debug issues\n\n3. **Best Practices**\n   - Organize flows well\n   - Use clear naming\n   - Add good documentation\n   - Create helpful visualizations\n\n\n---\n\n---\n# File: docs/workbench/noop-steps.md\n\n---\nsidebar_position: 8\ntitle: NoOp Steps\n---\n\n# NoOp Steps\nTODO: Need to show examples with images on this page\nNoOp (No Operation) steps are a powerful feature in Motia that serve multiple purposes:\n\n1. Modeling external processes, webhooks and integrations\n2. Representing human-in-the-loop activities\n3. Creating custom visualizations in the workbench\n4. Testing flows during development\n\n## Representing External Processes\n\nNoOp steps represent parts of your workflow that happen outside your system. Common examples include:\n\n### 1. Webhook Callbacks\n\n```typescript\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Wait for Stripe Webhook',\n  description: 'Waits for payment confirmation',\n  virtualSubscribes: ['payment.initiated'],\n  virtualEmits: ['/api/stripe/webhook'],\n  flows: ['payment'],\n}\n```\n\n### 2. Human Approvals\n\n```typescript\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Manager Review',\n  description: 'Manager reviews request',\n  virtualSubscribes: ['approval.requested'],\n  virtualEmits: ['/api/approvals/submit'],\n  flows: ['approval'],\n}\n```\n\n### 3. External System Integration\n\n```typescript\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'GitHub Webhook',\n  description: 'Waiting for repository events',\n  virtualSubscribes: ['repository.watched'],\n  virtualEmits: ['/api/github/webhook'],\n  flows: ['repo-automation'],\n}\n```\n\n### 4. Physical Processes\n\n```typescript\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Order Fulfillment',\n  description: 'Warehouse processes order',\n  virtualSubscribes: ['order.placed'],\n  virtualEmits: ['/api/warehouse/status'],\n  flows: ['fulfillment'],\n}\n```\n\n## Visualization in Workbench\n\nNoOp steps appear differently in the Motia Workbench to help visualize your flow:\n\n1. They show as distinct nodes in the flow diagram\n2. Virtual events appear as connections\n3. The waiting period is clearly visualized\n4. External dependencies are obvious\n\n## Custom UI Components\n\nYou can enhance your NoOp steps with custom React components for better visualization:\n\n```typescript\n// customNode.step.tsx\nimport React from 'react'\nimport { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'\n\nexport default (_: EventNodeProps) => {\n  return (\n    <div className=\"p-3 px-6 flex flex-col max-w-[300px] bg-blue-500 border-white rounded-full text-white border border-solid text-center text-sm\">\n      <div>Custom Processing</div>\n      <BaseHandle type=\"target\" position={Position.Top} />\n      <BaseHandle type=\"source\" position={Position.Bottom} />\n    </div>\n  )\n}\n\n// customNode.step.ts\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Custom Process',\n  virtualEmits: ['/api/process/complete'],\n  virtualSubscribes: ['process.start'],\n  flows: ['custom-flow']\n}\n```\n\n## Testing in Workbench\n\nNoOp steps are particularly useful for testing flows in development. Here's a complete example:\n\n### 1. Start Test Node\n\n```typescript\n// startTest.step.tsx\nimport React from 'react'\nimport { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'\n\nexport default (_: EventNodeProps) => {\n  return (\n    <div className=\"p-4 bg-green-500 rounded-full text-white text-center\">\n      <div>Start Test Flow</div>\n      <BaseHandle type=\"source\" position={Position.Bottom} />\n    </div>\n  )\n}\n\n// startTest.step.ts\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Start Test',\n  virtualEmits: ['/api/test/start'],\n  virtualSubscribes: [],\n  flows: ['test-flow']\n}\n```\n\n### 2. Monitor Progress\n\n```typescript\n// monitor.step.tsx\nimport React from 'react'\nimport { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'\n\nexport default (_: EventNodeProps) => {\n  return (\n    <div className=\"p-4 bg-yellow-500 rounded-full text-white text-center\">\n      <div>Monitoring Progress</div>\n      <BaseHandle type=\"target\" position={Position.Top} />\n      <BaseHandle type=\"source\" position={Position.Bottom} />\n    </div>\n  )\n}\n\n// monitor.step.ts\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'Monitor',\n  virtualEmits: ['/api/test/status'],\n  virtualSubscribes: ['test.running'],\n  flows: ['test-flow']\n}\n```\n\n### 3. End Test Node\n\n```typescript\n// endTest.step.tsx\nimport React from 'react'\nimport { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'\n\nexport default (_: EventNodeProps) => {\n  return (\n    <div className=\"p-4 bg-red-500 rounded-full text-white text-center\">\n      <div>End Test Flow</div>\n      <BaseHandle type=\"target\" position={Position.Top} />\n    </div>\n  )\n}\n\n// endTest.step.ts\nexport const config: NoopConfig = {\n  type: 'noop',\n  name: 'End Test',\n  virtualEmits: [],\n  virtualSubscribes: ['test.completed'],\n  flows: ['test-flow']\n}\n```\n\n## Best Practices\n\n1. **External Process Modeling**\n\n   - Use clear, descriptive names\n   - Document expected timeframes\n   - Include all possible outcomes\n   - Match API routes exactly\n\n2. **UI Components**\n\n   - Use Tailwind's core utility classes\n   - Keep components simple\n   - Make connections obvious\n   - Use consistent styling\n\n3. **Testing**\n   - Create dedicated test flows\n   - Use visual indicators\n   - Make test steps obvious\n   - Document test procedures\n\n## Available Component Tools\n\n1. **Core Imports**\n\n   ```typescript\n   import { BaseHandle, EventNodeProps, Position } from '@motiadev/workbench'\n   ```\n\n2. **Handle Placement**\n\n   - Top for inputs\n   - Bottom for outputs\n   - Match your flow direction\n\n3. **Styling Guidelines**\n   - Use semantic colors\n   - Keep text readable\n   - Show state clearly\n   - Maintain consistency\n\n## Next Steps\n\n1. **Start Simple**\n\n   - Model basic external processes\n   - Add custom visualization\n   - Create test flows\n\n2. **Expand Usage**\n\n   - Add more complex scenarios\n   - Enhance visualizations\n   - Build comprehensive tests\n\n3. **Optimize**\n   - Refine component library\n   - Improve test coverage\n   - Document patterns\n\n\n---\n\n---\n# File: docs/workbench/step-visualization-and-overrides.md\n\n---\nsidebar_position: 9\ntitle: Step Visualization And Overrides\n---\n\n# Step Visualization\nTODO: Need to show examples with images on this page\nEvery step in Motia can have a custom visualization in the workbench by providing a React component. This allows you to:\n\n- Create more intuitive flow diagrams\n- Add visual feedback for different states\n- Make testing and development easier\n- Provide better documentation through the UI\n\n## Basic Override\n\nTo override a step's visualization:\n\n1. Create a `.tsx` file next to your step with the same base name:\n\n```\nsteps/\n  └── myStep/\n      ├── myStep.step.ts      # Step definition\n      └── myStep.step.tsx     # Visual override\n```\n\n2. Export a default React component:\n\n```typescript\n// myStep.step.tsx\nimport React from 'react'\nimport { EventNode, EventNodeProps } from '@motiadev/workbench'\n\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode\n      data={data}\n      variant=\"white\"\n      className=\"py-2 px-4\"\n    />\n  )\n}\n```\n\n## Available Base Components\n\nMotia provides several base components for building step visualizations:\n\n### 1. EventNode\n\nFor general purpose steps:\n\n```typescript\nimport { EventNode, EventNodeProps } from '@motiadev/workbench'\n\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode\n      data={data}\n      variant=\"white\" // 'white' | 'ghost' | 'noop'\n      shape=\"rounded\" // 'rounded' | 'square' | 'noop'\n      className=\"custom-styles\"\n    >\n      <div>Custom content here</div>\n    </EventNode>\n  )\n}\n```\n\n### 2. ApiNode\n\nFor API and api steps:\n\n```typescript\nimport { ApiNode, ApiNodeProps } from '@motiadev/workbench'\n\nexport default ({ data }: ApiNodeProps) => {\n  return (\n    <ApiNode\n      data={data}\n      className=\"custom-styles\"\n    >\n      <div>Custom api content</div>\n    </ApiNode>\n  )\n}\n```\n\n### 3. BaseHandle\n\nFor custom node connections:\n\n```typescript\nimport { BaseHandle, Position } from '@motiadev/workbench'\n\nexport default () => {\n  return (\n    <div className=\"custom-node\">\n      <BaseHandle\n        type=\"target\"\n        position={Position.Top}\n      />\n      <div>Node content</div>\n      <BaseHandle\n        type=\"source\"\n        position={Position.Bottom}\n      />\n    </div>\n  )\n}\n```\n\n## Styling Rules\n\n1. Use Tailwind's core utility classes only\n2. No arbitrary values (wrong: w-[123px], correct: w-32)\n3. Keep styling responsive and flexible\n4. Match Motia's visual design system\n\n## Real-World Examples\n\n### Processing Step\n\n```typescript\nimport React from 'react'\nimport { EventNode, EventNodeProps } from '@motiadev/workbench'\n\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode\n      data={data}\n      variant=\"ghost\"\n      className=\"bg-blue-500 text-white rounded-full px-6 py-3\"\n    >\n      <div className=\"flex items-center gap-2\">\n        <ProcessingIcon className=\"w-4 h-4\" />\n        <span>Processing Data</span>\n      </div>\n    </EventNode>\n  )\n}\n```\n\n### API Endpoint\n\n```typescript\nimport React from 'react'\nimport { ApiNode, ApiNodeProps } from '@motiadev/workbench'\nimport { Globe } from 'lucide-react'\n\nexport default ({ data }: ApiNodeProps) => {\n  return (\n    <ApiNode\n      data={data}\n      className=\"border-sky-500\"\n    >\n      <div className=\"flex items-center gap-2\">\n        <Globe className=\"w-4 h-4\" />\n        <span>{data.name}</span>\n      </div>\n    </ApiNode>\n  )\n}\n```\n\n### Custom Node\n\n```typescript\nimport React from 'react'\nimport { BaseHandle, Position, EventNodeProps } from '@motiadev/workbench'\n\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <div className=\"bg-green-500 text-white rounded-full p-4 text-center\">\n      <BaseHandle type=\"target\" position={Position.Top} />\n      <div>{data.name}</div>\n      <div className=\"text-sm\">{data.description}</div>\n      <BaseHandle type=\"source\" position={Position.Bottom} />\n    </div>\n  )\n}\n```\n\n## Common Patterns\n\n### 1. State Indication\n\n```typescript\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode\n      data={data}\n      variant={isActive ? \"white\" : \"ghost\"}\n      className={cn(\n        \"transition-colors\",\n        isActive && \"bg-green-500\",\n        isError && \"bg-red-500\"\n      )}\n    />\n  )\n}\n```\n\n### 2. Progress Visualization\n\n```typescript\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode data={data}>\n      <div className=\"relative w-full h-2 bg-gray-200 rounded\">\n        <div\n          className=\"absolute h-2 bg-blue-500 rounded\"\n          style={{ width: `${progress}%` }}\n        />\n      </div>\n    </EventNode>\n  )\n}\n```\n\n### 3. Interactive Elements\n\n```typescript\nexport default ({ data }: EventNodeProps) => {\n  return (\n    <EventNode data={data}>\n      <button\n        className=\"px-2 py-1 bg-blue-500 text-white rounded\"\n        onClick={() => console.log('Clicked')}\n      >\n        Trigger\n      </button>\n    </EventNode>\n  )\n}\n```\n\n## Best Practices\n\n1. **Keep it Simple**\n\n   - Use base components when possible\n   - Minimize custom styling\n   - Make connections clear\n\n2. **Visual Clarity**\n\n   - Show state clearly\n   - Use consistent colors\n   - Keep text readable\n\n3. **Performance**\n\n   - Avoid heavy computations\n   - Minimize state usage\n   - Keep components light\n\n4. **Maintenance**\n   - Document custom components\n   - Use consistent patterns\n   - Share common styles\n\n## Next Steps\n\n1. Review existing step visualizations in your project\n2. Identify steps that need custom visualization\n3. Create reusable components for common patterns\n4. Document your visual design system\n\n\n---\n\n"
}