---
title: State Management
description: Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
---

State management is fundamental to building robust and dynamic workflows in Motia.dev. Our system is designed to be powerful yet simple, providing you with everything you need to maintain state across your flows and steps:

✨ **Zero Configuration (Default):** In-memory storage out of the box for quick setup. <br />
🔌 **Flexible Storage Options:** Choose from Memory, File, and Redis adapters to suit your persistence needs. <br />
🧹 **Automatic State Cleanup:** Optional Time-To-Live (TTL) support for automatic state expiration (Redis). <br />
🔒 **Built-in Isolation:** Each flow execution can use its own isolated state, ensuring data separation and security. <br />

## Core Concepts: State Manager Methods

The `state` object, accessible within your step handlers via the `ctx` context, provides comprehensive methods for state management. **All operations are atomic by default**, ensuring data consistency in concurrent scenarios.

### Basic Operations

| Method    | Parameters                             | Return Type          | Description                                                                                                                                                                                   |
| --------- | -------------------------------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `get`     | `scope: string, key: string`           | `Promise<T \| null>` | Retrieves a value associated with the given `key` and `scope` from the state store. Returns `null` if the key is not found. The type `T` is inferred based on how you use the returned value. |
| `set`     | `scope: string, key: string, value: T` | `Promise<T>`         | Stores a `value` associated with the given `key` and `scope` in the state store. The type `T` can be any serializable JavaScript/JSON value. Returns the stored value.                        |
| `update`  | `scope: string, key: string, updateFn: (current: T \| null) => T` | `Promise<T>` | Atomically updates a value using a function. The function receives the current value (or null) and returns the new value. **Note:** Over RPC, this is disabled by default for security reasons. Use atomic operations instead. |
| `delete`  | `scope: string, key: string`           | `Promise<T \| null>` | Removes the key-value pair associated with the given `key` and `scope` from the state store. Returns the deleted value.                                                                       |
| `clear`   | `scope: string`                        | `Promise<void>`      | Removes **all** state data associated with the provided `scope`. This is useful for cleaning up state for a specific scope.                                                                   |
| `exists`  | `scope: string, key: string`           | `Promise<boolean>`   | Checks if a key exists in the state store for the given scope.                                                                                                                                |
| `cleanup` | _(None)_                               | `Promise<void>`      | Performs periodic maintenance tasks, such as removing expired state data (TTL cleanup). The actual implementation depends on the configured state adapter.                                    |

### Atomic Primitives

| Method           | Parameters                                    | Return Type        | Description                                                                                                 |
| ---------------- | --------------------------------------------- | ------------------ | ----------------------------------------------------------------------------------------------------------- |
| `increment`      | `scope: string, key: string, delta?: number` | `Promise<number>`  | Atomically increments a numeric value by the specified delta (default: 1). Creates the key with value 0 if it doesn't exist. |
| `decrement`      | `scope: string, key: string, delta?: number` | `Promise<number>`  | Atomically decrements a numeric value by the specified delta (default: 1). **Note:** Values are clamped to 0 (never negative). |
| `compareAndSwap` | `scope: string, key: string, expected: T \| null, newValue: T` | `Promise<boolean>` | Atomically compares the current value with `expected` and sets it to `newValue` if they match. For objects, uses JSON comparison for deep equality. Returns true if the swap was successful. |

### Array Operations

| Method    | Parameters                                    | Return Type        | Description                                                                                                 |
| --------- | --------------------------------------------- | ------------------ | ----------------------------------------------------------------------------------------------------------- |
| `push`    | `scope: string, key: string, ...items: T[]`  | `Promise<T[]>`     | Atomically adds items to the end of an array. Creates the key as an empty array if it doesn't exist.       |
| `pop`     | `scope: string, key: string`                  | `Promise<T \| null>` | Atomically removes and returns the last item from an array. Returns null if the array is empty.            |
| `shift`   | `scope: string, key: string`                  | `Promise<T \| null>` | Atomically removes and returns the first item from an array. Returns null if the array is empty.           |
| `unshift` | `scope: string, key: string, ...items: T[]`  | `Promise<T[]>`     | Atomically adds items to the beginning of an array. Creates the key as an empty array if it doesn't exist. |

### Object Operations

| Method       | Parameters                                    | Return Type | Description                                                                                                 |
| ------------ | --------------------------------------------- | ----------- | ----------------------------------------------------------------------------------------------------------- |
| `setField`   | `scope: string, key: string, field: K, value: T[K]` | `Promise<T>` | Atomically sets a field in an object. Creates the key as an empty object if it doesn't exist.              |
| `deleteField`| `scope: string, key: string, field: string`  | `Promise<T>` | Atomically removes a field from an object. Creates the key as an empty object if it doesn't exist.         |

### Transaction and Batch Operations

| Method        | Parameters                                    | Return Type                    | Description                                                                                                 |
| ------------- | --------------------------------------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------------- |
| `transaction` | `scope: string, operations: StateOperation[]` | `Promise<TransactionResult<T>>` | Executes multiple operations atomically. All operations succeed or all fail. **Note:** Atomic per adapter (Memory/File). |
| `batch`       | `scope: string, operations: BatchOperation[]` | `Promise<BatchResult<T>>`      | Executes multiple operations in parallel. Individual operations can succeed or fail independently. **Note:** Not transactional - operations can interleave. |

**Important:** State manager methods (`get`, `set`, `delete`, `clear`) **require a `scope` string as the first parameter.** While in most cases, you will use the `traceId` (automatically provided in `ctx.traceId`) as the scope to ensure flow-level isolation, **you can technically use any string value as the scope** to group and manage state data as needed. Using `traceId` is the recommended and most common practice for flow-isolated state.

### State Scope and Isolation

Each flow execution in Motia.dev is assigned a unique `traceId` (a UUID). Using this `traceId` as the **scope** for state management provides automatic isolation, ensuring: _(Revised to clarify `traceId` as scope)_

| Feature        | Description                                                                                                         |
| -------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Isolation**  | Each flow execution operates within its own isolated state space when using `traceId` as the scope.                 |
| **Boundaries** | Clear separation of state data between different flow executions when scoped by `traceId`, preventing interference. |
| **Cleanup**    | State data scoped by `traceId` can be easily cleared using `state.clear(traceId)`.                                  |

### State Structure Example

State data is stored as key-value pairs, namespaced under a scope string. When using `traceId` as the scope, the internal structure might look like this:

```typescript
// Example state structure (internal representation) - using traceId as scope
{
  "motia:state:{traceId-123}": {  // State for flow execution with traceId 'traceId-123' (scope)
    "booking": {                 // Namespaced key 'booking'
      "customer": { ... },
      "venue": { ... }
    },
    "payment": {                 // Namespaced key 'payment'
      "status": "pending",
      "amount": 100
    }
  },
  "motia:state:{traceId-456}": {  // State for another flow execution with traceId 'traceId-456' (different scope)
    // ... different state data for this flow ...
  }
}
```

> **Info:** You can access the `state` manager within any step through the `ctx` (context) argument, which is automatically injected into your [step handler](/docs/concepts/steps/defining-steps#handler). While **`traceId` from `ctx.traceId` is the recommended scope for flow isolation**, remember that **you can use any string as the scope** parameter in `state` methods for more advanced state management scenarios.

## Using State in Steps

### Basic Operations

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  import { Handlers } from 'motia'

  interface BookingData {
    customer: { name: string; email: string };
    venue: { id: string; name: string };
  }

  export const handler: Handlers['StepName'] = async (input, { state, traceId }) => {
    // Store state (using traceId as scope)
    await state.set<BookingData>(traceId, 'booking', {
      customer: input.customer,
      venue: input.venue,
    });

    // Retrieve state (using traceId as scope)
    const booking = await state.get<BookingData>(traceId, 'booking');

    // Check if key exists
    const exists = await state.exists(traceId, 'booking');

    // Update state atomically
    await state.update(traceId, 'booking', (current) => ({
      ...current,
      status: 'confirmed'
    }));

    // Delete specific state (using traceId as scope)
    await state.delete(traceId, 'booking');

    // Clear all state for this flow (using traceId as scope)
    await state.clear(traceId);
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  import { Handlers } from 'motia'

  export const handler: Handlers['StepName'] = async (input, { state, traceId }) => {
    // Store state (using traceId as scope)
    await state.set(traceId, 'booking', {
      customer: input.customer,
      venue: input.venue,
    });

    // Retrieve state (using traceId as scope)
    const booking = await state.get(traceId, 'booking');

    // Check if key exists
    const exists = await state.exists(traceId, 'booking');

    // Update state atomically
    await state.update(traceId, 'booking', (current) => ({
      ...current,
      status: 'confirmed'
    }));

    // Delete specific state (using traceId as scope)
    await state.delete(traceId, 'booking');

    // Clear all state for this flow (using traceId as scope)
    await state.clear(traceId);
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id

      # Store state (using traceId as scope)
      await ctx.state.set(trace_id, 'booking', {
          'customer': input.get("customer"),
          'venue': input.get("venue")
      })

      # Retrieve state (using traceId as scope)
      booking = await ctx.state.get(trace_id, 'booking')

      # Check if key exists
      exists = await ctx.state.exists(trace_id, 'booking')

      # Update state atomically
      await ctx.state.update(trace_id, 'booking', lambda current: {
          **current,
          'status': 'confirmed'
      })

      # Delete specific state (using traceId as scope)
      await ctx.state.delete(trace_id, 'booking')

      # Clear all state (using traceId as scope)
      await ctx.state.clear(trace_id)
  ```
  </Tab>
</Tabs>

### Atomic Primitives

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  export const handler: Handlers['CounterStep'] = async (input, { state, traceId }) => {
    // Atomic increment (creates key with value 0 if it doesn't exist)
    const count = await state.increment(traceId, 'pageViews');
    
    // Atomic increment with custom delta
    const score = await state.increment(traceId, 'userScore', 10);
    
    // Atomic decrement (never goes below 0)
    const remaining = await state.decrement(traceId, 'tickets', 1);
    
    // Compare and swap for optimistic locking
    const success = await state.compareAndSwap(traceId, 'userStatus', 'pending', 'active');
    
    if (success) {
      console.log('User status updated successfully');
    } else {
      console.log('User status was already changed by another process');
    }
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    // Atomic increment (creates key with value 0 if it doesn't exist)
    const count = await state.increment(traceId, 'pageViews');
    
    // Atomic increment with custom delta
    const score = await state.increment(traceId, 'userScore', 10);
    
    // Atomic decrement (never goes below 0)
    const remaining = await state.decrement(traceId, 'tickets', 1);
    
    // Compare and swap for optimistic locking
    const success = await state.compareAndSwap(traceId, 'userStatus', 'pending', 'active');
    
    if (success) {
      console.log('User status updated successfully');
    } else {
      console.log('User status was already changed by another process');
    }
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      
      # Atomic increment (creates key with value 0 if it doesn't exist)
      count = await ctx.state.increment(trace_id, 'pageViews')
      
      # Atomic increment with custom delta
      score = await ctx.state.increment(trace_id, 'userScore', 10)
      
      # Atomic decrement (never goes below 0)
      remaining = await ctx.state.decrement(trace_id, 'tickets', 1)
      
      # Compare and swap for optimistic locking
      success = await ctx.state.compare_and_swap(trace_id, 'userStatus', 'pending', 'active')
      
      if success:
          print('User status updated successfully')
      else:
          print('User status was already changed by another process')
  ```
  </Tab>
</Tabs>

### Array Operations

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  export const handler: Handlers['ArrayStep'] = async (input, { state, traceId }) => {
    // Add items to the end of an array
    const items = await state.push(traceId, 'shoppingCart', 'apple', 'banana');
    
    // Add items to the beginning of an array
    const queue = await state.unshift(traceId, 'processingQueue', 'urgent-task');
    
    // Remove and get the last item
    const lastItem = await state.pop(traceId, 'shoppingCart');
    
    // Remove and get the first item
    const firstTask = await state.shift(traceId, 'processingQueue');
    
    console.log('Shopping cart:', items);
    console.log('Last item removed:', lastItem);
    console.log('First task processed:', firstTask);
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    // Add items to the end of an array
    const items = await state.push(traceId, 'shoppingCart', 'apple', 'banana');
    
    // Add items to the beginning of an array
    const queue = await state.unshift(traceId, 'processingQueue', 'urgent-task');
    
    // Remove and get the last item
    const lastItem = await state.pop(traceId, 'shoppingCart');
    
    // Remove and get the first item
    const firstTask = await state.shift(traceId, 'processingQueue');
    
    console.log('Shopping cart:', items);
    console.log('Last item removed:', lastItem);
    console.log('First task processed:', firstTask);
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      
      # Add items to the end of an array
      items = await ctx.state.push(trace_id, 'shoppingCart', 'apple', 'banana')
      
      # Add items to the beginning of an array
      queue = await ctx.state.unshift(trace_id, 'processingQueue', 'urgent-task')
      
      # Remove and get the last item
      last_item = await ctx.state.pop(trace_id, 'shoppingCart')
      
      # Remove and get the first item
      first_task = await ctx.state.shift(trace_id, 'processingQueue')
      
      print('Shopping cart:', items)
      print('Last item removed:', last_item)
      print('First task processed:', first_task)
  ```
  </Tab>
</Tabs>

### Object Operations

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  export const handler: Handlers['ObjectStep'] = async (input, { state, traceId }) => {
    // Set a field in an object atomically
    const user = await state.setField(traceId, 'user', 'lastLogin', new Date().toISOString());
    
    // Update multiple fields
    await state.setField(traceId, 'user', 'loginCount', 1);
    await state.setField(traceId, 'user', 'status', 'active');
    
    // Remove a field from an object
    const cleanedUser = await state.deleteField(traceId, 'user', 'temporaryData');
    
    console.log('Updated user:', user);
    console.log('Cleaned user:', cleanedUser);
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    // Set a field in an object atomically
    const user = await state.setField(traceId, 'user', 'lastLogin', new Date().toISOString());
    
    // Update multiple fields
    await state.setField(traceId, 'user', 'loginCount', 1);
    await state.setField(traceId, 'user', 'status', 'active');
    
    // Remove a field from an object
    const cleanedUser = await state.deleteField(traceId, 'user', 'temporaryData');
    
    console.log('Updated user:', user);
    console.log('Cleaned user:', cleanedUser);
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      
      # Set a field in an object atomically
      user = await ctx.state.set_field(trace_id, 'user', 'lastLogin', datetime.now().isoformat())
      
      # Update multiple fields
      await ctx.state.set_field(trace_id, 'user', 'loginCount', 1)
      await ctx.state.set_field(trace_id, 'user', 'status', 'active')
      
      # Remove a field from an object
      cleaned_user = await ctx.state.delete_field(trace_id, 'user', 'temporaryData')
      
      print('Updated user:', user)
      print('Cleaned user:', cleaned_user)
  ```
  </Tab>
</Tabs>

### Transaction Operations

Transactions ensure that multiple operations either all succeed or all fail together, maintaining data consistency:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  export const handler: Handlers['TransactionStep'] = async (input, { state, traceId }) => {
    const operations = [
      { type: 'set', key: 'user', value: { name: 'John', balance: 100 } },
      { type: 'increment', key: 'totalUsers', delta: 1 },
      { type: 'push', key: 'userLog', items: ['user created'] },
      { type: 'setField', key: 'user', field: 'status', value: 'active' }
    ];

    const result = await state.transaction(traceId, operations);
    
    if (result.success) {
      console.log('All operations completed successfully');
      console.log('Results:', result.results);
    } else {
      console.error('Transaction failed:', result.error);
      // All operations were rolled back
    }
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    const operations = [
      { type: 'set', key: 'user', value: { name: 'John', balance: 100 } },
      { type: 'increment', key: 'totalUsers', delta: 1 },
      { type: 'push', key: 'userLog', items: ['user created'] },
      { type: 'setField', key: 'user', field: 'status', value: 'active' }
    ];

    const result = await state.transaction(traceId, operations);
    
    if (result.success) {
      console.log('All operations completed successfully');
      console.log('Results:', result.results);
    } else {
      console.error('Transaction failed:', result.error);
      // All operations were rolled back
    }
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      
      operations = [
          { 'type': 'set', 'key': 'user', 'value': { 'name': 'John', 'balance': 100 } },
          { 'type': 'increment', 'key': 'totalUsers', 'delta': 1 },
          { 'type': 'push', 'key': 'userLog', 'items': ['user created'] },
          { 'type': 'setField', 'key': 'user', 'field': 'status', 'value': 'active' }
      ]

      result = await ctx.state.transaction(trace_id, operations)
      
      if result['success']:
          print('All operations completed successfully')
          print('Results:', result['results'])
      else:
          print('Transaction failed:', result['error'])
          # All operations were rolled back
  ```
  </Tab>
</Tabs>

### Batch Operations

Batch operations execute multiple operations in parallel, with individual success/failure tracking:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  export const handler: Handlers['BatchStep'] = async (input, { state, traceId }) => {
    const operations = [
      { type: 'get', key: 'user1', id: 'op1' },
      { type: 'get', key: 'user2', id: 'op2' },
      { type: 'increment', key: 'counter1', delta: 1, id: 'op3' },
      { type: 'increment', key: 'counter2', delta: 5, id: 'op4' }
    ];

    const result = await state.batch(traceId, operations);
    
    // Check individual operation results
    for (const opResult of result.results) {
      if (opResult.error) {
        console.error(`Operation ${opResult.id} failed:`, opResult.error);
      } else {
        console.log(`Operation ${opResult.id} succeeded:`, opResult.value);
      }
    }
  }
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    const operations = [
      { type: 'get', key: 'user1', id: 'op1' },
      { type: 'get', key: 'user2', id: 'op2' },
      { type: 'increment', key: 'counter1', delta: 1, id: 'op3' },
      { type: 'increment', key: 'counter2', delta: 5, id: 'op4' }
    ];

    const result = await state.batch(traceId, operations);
    
    // Check individual operation results
    for (const opResult of result.results) {
      if (opResult.error) {
        console.error(`Operation ${opResult.id} failed:`, opResult.error);
      } else {
        console.log(`Operation ${opResult.id} succeeded:`, opResult.value);
      }
    }
  }
  ```

  </Tab>

  <Tab label="Python">
  
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      
      operations = [
          { 'type': 'get', 'key': 'user1', 'id': 'op1' },
          { 'type': 'get', 'key': 'user2', 'id': 'op2' },
          { 'type': 'increment', 'key': 'counter1', 'delta': 1, 'id': 'op3' },
          { 'type': 'increment', 'key': 'counter2', 'delta': 5, 'id': 'op4' }
      ]

      result = await ctx.state.batch(trace_id, operations)
      
      # Check individual operation results
      for op_result in result['results']:
          if op_result.get('error'):
              print(f"Operation {op_result['id']} failed:", op_result['error'])
          else:
              print(f"Operation {op_result['id']} succeeded:", op_result['value'])
  ```
  </Tab>
</Tabs>

## Debugging

### Inspecting State

<Tabs items={['Memory', 'File', 'Redis']}>
  <Tab label="Memory">
  > State is only available during runtime in the Node.js process memory. You cannot inspect memory state directly outside of a running step execution. Use logging within your steps to output state values for debugging purposes.
  </Tab>
  <Tab label="File">
  
  To inspect state stored in the **File Adapter**, you can directly view the contents of the state file using the Motia CLI:

  ```bash
  # View state file contents
  motia state list
  ```

  This command will output the entire state file (motia.state.json) content in JSON format to your console, allowing you to examine the stored state data.

  </Tab>
  <Tab label="Redis">
  
  To inspect state stored in **Redis Adapter**, you can use the `redis-cli` command-line tool to interact with your Redis server:

  ```bash
  # List all state keys (under the motia:state prefix)
  redis-cli KEYS "motia:state:*"

  # Get specific state for a given traceId and key
  redis-cli GET "motia:state:{traceId}:booking"
  ```
  **Note:** Replace `{traceId}` in the `redis-cli GET` command with the actual `traceId` of the flow execution you are debugging. Replace `booking` with the specific `key` you want to inspect.

  </Tab>
</Tabs>

## Best Practices

### Namespacing

Use dot notation to organize related state data hierarchically:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  // Good - Organized hierarchically (using traceId scope)
  await state.set(traceId, 'booking.customer', customerData)
  await state.set(traceId, 'booking.venue', venueData)
  await state.set(traceId, 'payment.status', 'pending')

  // Avoid - Flat structure (using traceId scope)
  await state.set(traceId, 'customer', customerData)
  await state.set(traceId, 'venue', venueData)
  await state.set(traceId, 'paymentStatus', 'pending')
  ```

  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  // Good - Organized hierarchically (using traceId scope)
  await state.set(traceId, 'booking.customer', customerData)
  await state.set(traceId, 'booking.venue', venueData)
  await state.set(traceId, 'payment.status', 'pending')

  // Avoid - Flat structure (using traceId scope)
  await state.set(traceId, 'customer', customerData)
  await state.set(traceId, 'venue', venueData)
  await state.set(traceId, 'paymentStatus', 'pending')
  ```

  </Tab>

  <Tab label="Python">
    
  ```python
  # Good - Organized hierarchically (using traceId scope)
  await ctx.state.set(trace_id, 'booking.customer', customer_data)
  await ctx.state.set(trace_id, 'booking.venue', venue_data)
  await ctx.state.set(trace_id, 'payment.status', 'pending')

  // Avoid - Flat structure (using traceId scope)
  await ctx.state.set(trace_id, 'customer', customer_data)
  await ctx.state.set(trace_id, 'venue', venue_data)
  await ctx.state.set(trace_id, 'payment_status', 'pending')
  ```

  </Tab>
</Tabs>

### Type Safety

Define types for your state data to ensure consistency:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    
  ```typescript
  interface CustomerData {
    name: string;
    email: string;
  }

  interface VenueData {
    id: string;
    capacity: number;
  }

  type BookingState = {
    customer: CustomerData;
    venue: VenueData;
    status: 'pending' | 'confirmed';
  }

  const booking = await state.get<BookingState>(traceId, 'booking')
  ```

  </Tab>

{' '}
  <Tab label="JavaScript">
  
  ```javascript 
  // Define types or interfaces as needed for documentation clarity (optional in JS) const booking = await
  state.get(traceId, 'booking') // No type casting in JS example 
  ```
  </Tab>

  <Tab label="Python">
    
  ```python
  from dataclasses import dataclass
  from typing import Literal

  @dataclass
  class CustomerData:
      name: str
      email: str

  @dataclass
  class VenueData:
      id: str
      capacity: int

  @dataclass
  class BookingState:
      customer: CustomerData
      venue: VenueData
      status: Literal['pending', 'confirmed']

  booking = await state.get(traceId, 'booking')
  ```

  </Tab>
</Tabs>

### Cleanup

Always clean up state when you're done with it:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
      
  ```typescript
  export const handler: Handlers['StepName'] = async (input, { state, traceId }) => {
    try {
      await processBooking(input)
      // Clean up specific keys
      await state.delete(traceId, 'booking.customer')
      // Or clean everything
      await state.clear(traceId)
    } catch (error) {
      // Handle errors
    }
  }
  ```
  </Tab>

  <Tab label="JavaScript">
    
  ```javascript
  export const handler = async (input, { state, traceId }) => {
    try {
      await processBooking(input)
      // Clean up specific keys
      await state.delete(traceId, 'booking.customer')
      // Or clean everything
      await state.clear(traceId)
    } catch (error) {
      // Handle errors
    }
  }
  ```
  </Tab>

  <Tab label="Python">
    
  ```python
  async def handler(input, ctx):
      trace_id = ctx.trace_id
      try:
          await process_booking(input)
          # Clean up specific keys
          await ctx.state.delete(trace_id, 'booking.customer')
          # Or clean everything
          await ctx.state.clear(trace_id)
      except Exception as error:
          # Handle errors
          pass
  ```
  </Tab>
</Tabs>

### Performance Considerations

| Consideration    | Description                                                          |
| ---------------- | -------------------------------------------------------------------- |
| Batch Operations | Group related state updates and use atomic operations when possible  |
| State Size       | Keep state data minimal and consider access patterns                 |
| TTL Management   | Set appropriate TTLs based on flow duration and error recovery needs |

### Custom State Adapters

```typescript title="Custom State Adapter Example"
import { StateAdapter } from 'motia'

class CustomStateAdapter extends StateAdapter {
  async get<T>(traceId: string, key: string): Promise<T | null> {
    // Implementation
    return null
  }

  async set<T>(traceId: string, key: string, value: T): Promise<void> {
    // Implementation
  }

  async delete(traceId: string, key: string): Promise<void> {
    // Implementation
  }

  async clear(traceId: string): Promise<void> {
    // Implementation
  }

  async cleanup(): Promise<void> {
    // Implementation
  }
}
```

### Storage Adapters

Motia.dev offers three built-in storage adapters:

- 📁 **File (Default):** Persists state to a JSON file in your project (`.motia/motia.state.json`). No configuration needed for basic use.
- 💾 **Memory:** Stores state in-memory. Fastest option, but state is not persistent across server restarts. Useful for development and non-critical data.
- ⚡ **Redis:** Leverages Redis for persistent and scalable state storage. Ideal for production environments and flows requiring high availability and data durability.

To configure a different state adapter, modify the `config.yml` file in your project root:

```
my-project/
├── config.yml
└── steps/
    ├── step-1.ts
    └── step-2.ts
```

**File Adapter (Default)**

> Default, no configuration required, state is stored into .motia/motia.state.json in your project root

**Memory Adapter**

```yaml title="config.yml"
state:
  adapter: memory
```

> **Warning: Memory Adapter**
> State is stored in-memory and will be lost when the Motia.dev server restarts. Suitable for development and testing.

**Redis Adapter**

```yaml title="config.yml"
state:
  adapter: redis
  host: localhost # Redis server host (e.g., 'localhost' or IP address)
  port: 6379 # Redis server port (default: 6379)
  password: optional # Redis password (if required)
  ttl: 3600 # Optional: State Time-To-Live in seconds (e.g., 3600 seconds = 1 hour)
```

> **Info: Redis Adapter**
> Recommended for production environments. Requires a running Redis server. The `ttl` (Time-To-Live) option is available to automatically expire state data after a specified number of seconds, helping to manage Redis storage.

### Security Considerations

#### RPC Update Function Security

The `state.update()` method over RPC (Remote Procedure Call) is **disabled by default** for security reasons:

- **Node.js**: Requires `ALLOW_RPC_UPDATE=1` environment variable to enable
- **Python/Ruby**: Not supported - throws `NotImplementedError`
- **Recommendation**: Use atomic operations (`increment`, `decrement`, `compareAndSwap`, etc.) instead

#### Multi-Language Support

- **TypeScript/JavaScript**: Full support for all operations including `update`
- **Python**: All operations supported except `update` (use atomic operations)
- **Ruby**: All operations supported except `update` (use atomic operations)

#### State Isolation

- Each flow execution uses a unique `traceId` as the scope
- State is automatically isolated between different flow executions
- Use consistent `traceId` values to ensure proper isolation

### Common Issues

| Issue             | Troubleshooting Steps                                                                                                                                                                            |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| State Not Found   | - Verify state adapter configuration\n- Check TTL expiration (Redis)\n- Ensure file permissions (File adapter)\n- **Ensure correct `traceId` is being used in `state.get(traceId, key)` calls.** |
| Persistence       | - Memory adapter: State is lost on process restart\n- File adapter: Check file write permissions\n- Redis: Verify connection and persistence settings                                            |
| Concurrent Access | - Memory/File: Limited concurrent flow support\n- Redis: Use atomic operations and implement retry logic                                                                                         |
