---
title: What is a Step?
description: One primitive to build any backend. Simple, composable, and multi-language.
---

# What is a Step?

## One Primitive for Any Backend

A **Step** is the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:   **how it runs, when it runs, where it runs, and what it does.**

Every Step file contains two parts:

- **Config** â†’ defines when and how the Step runs, and gives it a unique `name`  
- **Handler** â†’ the function that executes your business logic  

Motia automatically discovers any file ending in `.step.ts`, `.step.js`, or `_step.py`.  
The filename tells Motia to load it, and the `name` in the `config` uniquely identifies the Step inside your system.

---

## The Simplest Example

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/hello.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

export const handler: Handlers['HelloStep'] = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};
```

</Tab>
<Tab value='Python'>

```python title="steps/hello_step.py"
config = {
    "name": "HelloStep",
    "type": "api",
    "path": "/hello",
    "method": "GET"
}

async def handler(req, ctx):
    ctx.logger.info("Hello endpoint called")
    return {"status": 200, "body": {"message": "Hello world!"}}
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/hello.step.js"
const config = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

const handler = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

ðŸ‘‰ Thatâ€™s all you need to make a running API endpoint.  
Motia will auto-discover this file and wire it into your backend.

---

## Step Naming & Discovery

Motia automatically discovers Steps by scanning your project for files that follow these naming conventions:

- `*.step.ts` or `*.step.js` â†’ TypeScript / JavaScript Steps  
- `*_step.py` â†’ Python Steps  

Each Step file must export both a `config` and a `handler`.  

The `name` field in the `config` is the **unique identifier** for your Step inside Motia.  
Itâ€™s how your Step is typed, referenced in handlers, and connected in flows.  

ðŸ‘‰ **Filenames are for auto-discovery, `name` is for identity.**  
You can rename a file, but the `name` property in `config` is what other Steps and flows use.

---

## Steps Work Together: Emit + Subscribe

Steps arenâ€™t isolated. They communicate by **emitting** and **subscribing** to events.  
This is the core of how you build backends with Motia.

### Example Flow: API Step â†’ Event Step

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/send-message.step.ts"
export const config = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

export const handler = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};
```

```ts title="steps/process-message.step.ts"
export const config = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

export const handler = async (input, { logger }) => {
  logger.info('Processing message', input);
};
```
</Tab>

<Tab value='Python'>

```python title="send_message_step.py"
config = {
    "name": "SendMessage",
    "type": "api",
    "path": "/messages",
    "method": "POST",
    "emits": ["message.sent"]
}

async def handler(req, ctx):
    await ctx.emit({
        "topic": "message.sent",
        "data": {"text": req.body["text"]}
    })
    return {"status": 200, "body": {"ok": True}}
```

```python title="process_message_step.py"
config = {
    "name": "ProcessMessage",
    "type": "event",
    "subscribes": ["message.sent"]
}

async def handler(input, ctx):
    ctx.logger.info("Processing message", input)
```
</Tab>

<Tab value='JavaScript'>

```js title="steps/send-message.step.js"
const config = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

const handler = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};

module.exports = { config, handler };
```

```js title="steps/process-message.step.js"
const config = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

const handler = async (input, { logger }) => {
  logger.info('Processing message', input);
};

module.exports = { config, handler };
```
</Tab>
</Tabs>

ðŸ‘‰ With just two files, you have an **API endpoint** that triggers an **event-driven workflow**.  

---

## Step Types

Every Step has a `type` that defines **how it triggers**. Change the type, and the same pattern works for different use cases.

| Type     | When it runs                 | Example use case |
|----------|------------------------------|------------------|
| `api`    | On an HTTP request           | REST endpoints, webhooks |
| `event`  | When an event is emitted     | Event-driven workflows |
| `cron`   | On a schedule                | Nightly jobs, reminders |

---

## Anatomy of a Step

Each Step file has two parts:

1. **Config** â€“ declarative metadata about the Step  
2. **Handler** â€“ the function that runs when the Step triggers

### Config Properties

Common to all Steps:

| Property | Type | Description |
|----------|------|-------------|
| `name`   | `string` | Unique identifier |
| `type`   | `'api' \| 'event' \| 'cron' \| Trigger type |
| `description` | `string` | Human-readable notes (optional) |
| `emits`  | `string[]` | Events this Step can emit |
| `subscribes` | `string[]` | Events this Step listens to |
| `flows`  | `string[]` | Flows this Step belongs to |

Additional properties depend on type (`api`, `event`, `cron`).

---

### Handler Function

The **handler** is where your business logic goes. Its signature depends on the Step type:

- **API Step** â†’ `(req, ctx)`  
- **Event Step** â†’ `(input, ctx)`  
- **Cron Step** â†’ `(ctx)`  

#### Context (`ctx`)

Every handler gets the same context object:

| Element | Description |
|---------|-------------|
| `emit` | Trigger other Steps by emitting events |
| `logger` | Structured logging (`info`, `warn`, `error`) |
| `state` | Persistent key-value storage |
| `streams` | Real-time data channels for clients |
| `traceId` | Unique ID for tracing requests & workflows |

---

## Core Fucntionality

### State â€“ Persistent Data

Key-value storage shared across Steps and workflows.

```ts
await state.set(traceId, 'preferences', { theme: 'dark' });
const prefs = await state.get(traceId, 'preferences');
```

### Logging â€“ Structured & Contextual

For debugging, monitoring, and observability.

```ts
logger.info('Processing user', { userId: '123' });
```

### Streams â€“ Real-Time Data

Push updates directly to connected clients.

```ts
await streams.chat.set('room-123', 'msg-456', { text: 'Hello!' });
```

---

## Remember

- **Steps are just files.** Export a `config` and `handler`.  
- Motia auto-discovers and connects them.  
- Combine Steps with **emit + subscribe** to build APIs, workflows, background jobs, or entire systems.  

---

## Whatâ€™s Next?

ðŸ‘‰ [Build your first app â†’](/docs/getting-started/build-your-first-app)
