---
title: Triggers
description: Understanding how Steps are triggered - API, Event, and Cron
---

## How Steps Are Triggered

Every Step has a `type` that defines **when it runs**. Change the type, and your handler works the same way, only the trigger changes.

| Type | Triggers when... | Use for |
|------|------------------|---------|
| `api` | An HTTP request arrives | REST endpoints, webhooks |
| `event` | An event is emitted | Background tasks, workflows |
| `cron` | A schedule fires | Periodic jobs, cleanups |

---

Let's learn each Step types one-by-one in details, just select tabs below to switch between triggers.

<Tabs items={['API', 'Event', 'Cron']}>
<Tab value='API'>

## API Trigger

API Triggers expose HTTP endpoints. When a request hits the path, your handler runs.

### The Simplest API Trigger

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'GetUser',
      path: '/users/:id',
      method: 'GET'
    }

    export const handler: Handlers['GetUser'] = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })

      return {
        status: 200,
        body: { id: userId, name: 'John Doe' }
      }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      type: 'api',
      name: 'GetUser',
      path: '/users/:id',
      method: 'GET'
    }

    const handler = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })

      return {
        status: 200,
        body: { id: userId, name: 'John Doe' }
      }
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "api",
        "name": "GetUser",
        "path": "/users/:id",
        "method": "GET"
    }

    async def handler(req, context):
        user_id = req.get("pathParams", {}).get("id")
        context.logger.info("Getting user", {"userId": user_id})

        return {
            "status": 200,
            "body": {"id": user_id, "name": "John Doe"}
        }
    ```
  </Tab>
</Tabs>

👉 That's it! You now have a `GET /users/:id` endpoint.

---

### API Handler Signature

Your handler receives two arguments:

```typescript
handler(req, ctx)
```

**`req`** contains the HTTP request:

| Property | Description |
|----------|-------------|
| `body` | Request body (parsed JSON) |
| `headers` | HTTP headers |
| `pathParams` | URL parameters (e.g., `:id` → `{ id: '123' }`) |
| `queryParams` | Query string parameters |

**`ctx`** is the same [context object](#context) all Steps get: `logger`, `emit`, `state`, `streams`, `traceId`.

**Return value** must include:

| Property | Description |
|----------|-------------|
| `status` | HTTP status code (200, 404, 500, etc.) |
| `body` | Response body (will be JSON-serialized) |
| `headers` | Optional response headers |

---

### Config Options

All API Steps require these:

| Property | Type | Description |
|----------|------|-------------|
| `type` | `'api'` | Marks this as an API Step |
| `name` | `string` | Unique identifier |
| `path` | `string` | URL path (supports `:params`) |
| `method` | `string` | HTTP method (GET, POST, PUT, DELETE, etc.) |

Optional properties:

| Property | Type | Description |
|----------|------|-------------|
| `description` | `string` | Human-readable notes |
| `emits` | `string[]` | Events this Step can emit |
| `flows` | `string[]` | Flows this Step belongs to |
| `bodySchema` | `ZodSchema \| PydanticModel` | Validate request body |
| `responseSchema` | `ZodSchema \| PydanticModel` | Document response shape |
| `queryParams` | `Array<{ name, description }>` | Document query params |
| `middleware` | `ApiMiddleware[]` | Pre-handler functions |

---

### Validating Input

Use schemas to validate request bodies automatically.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'CreateUser',
      path: '/users',
      method: 'POST',
      bodySchema: z.object({
        name: z.string(),
        email: z.string().email()
      })
    }

    export const handler: Handlers['CreateUser'] = async (req, { logger }) => {
      // req.body is validated and typed!
      logger.info('Creating user', req.body)

      return {
        status: 201,
        body: { id: '123', ...req.body }
      }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const { z } = require('zod')

    const config = {
      type: 'api',
      name: 'CreateUser',
      path: '/users',
      method: 'POST',
      bodySchema: z.object({
        name: z.string(),
        email: z.string().email()
      })
    }

    const handler = async (req, { logger }) => {
      // req.body is validated!
      logger.info('Creating user', req.body)

      return {
        status: 201,
        body: { id: '123', ...req.body }
      }
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    from pydantic import BaseModel, EmailStr
    
    class CreateUserBody(BaseModel):
        name: str
        email: EmailStr

    config = {
      "type": "api",
        "name": "CreateUser",
        "path": "/users",
        "method": "POST",
        "bodySchema": CreateUserBody
    }

    async def handler(req, context):
        # req.body is validated!
        context.logger.info("Creating user", req.get("body"))

      return {
            "status": 201,
            "body": {"id": "123", **req.get("body", {})}
      }
    ```
  </Tab>
</Tabs>

👉 Invalid requests return 400 automatically with validation errors.

---

### Using Middleware

Middleware runs **before** your handler. Use it for authentication, logging, rate limiting, etc.

**Signature:**

```typescript
middleware(req, ctx, next)
```

- `req` → The incoming request  
- `ctx` → Same context as handler  
- `next()` → Call to continue to the next middleware or handler  

👉 If you don't call `next()`, the request stops and never reaches your handler.

**Example:**

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiMiddleware, ApiRouteConfig, Handlers } from 'motia'

    const authMiddleware: ApiMiddleware = async (req, ctx, next) => {
      if (!req.headers.authorization) {
        return { status: 401, body: { error: 'Unauthorized' } }
      }
      return next() // Continue to handler
    }

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'ProtectedEndpoint',
      path: '/api/protected',
      method: 'POST',
      middleware: [authMiddleware]
    }

    export const handler: Handlers['ProtectedEndpoint'] = async (req, ctx) => {
      // Only runs if middleware calls next()
      return { status: 200, body: { message: 'Success!' } }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const authMiddleware = async (req, ctx, next) => {
      if (!req.headers.authorization) {
        return { status: 401, body: { error: 'Unauthorized' } }
      }
      return next() // Continue to handler
    }

    const config = {
      type: 'api',
      name: 'ProtectedEndpoint',
      path: '/api/protected',
      method: 'POST',
      middleware: [authMiddleware]
    }

    const handler = async (req, ctx) => {
      // Only runs if middleware calls next()
      return { status: 200, body: { message: 'Success!' } }
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    async def auth_middleware(req, context, next_fn):
        if not req.get("headers", {}).get("authorization"):
            return {"status": 401, "body": {"error": "Unauthorized"}}
        return await next_fn()  # Continue to handler

    config = {
        "type": "api",
        "name": "ProtectedEndpoint",
        "path": "/api/protected",
        "method": "POST",
        "middleware": [auth_middleware]
    }

    async def handler(req, context):
        # Only runs if middleware calls next()
        return {"status": 200, "body": {"message": "Success!"}}
    ```
  </Tab>
</Tabs>

👉 Middleware runs in order: first in the list runs first.

</Tab>

<Tab value='Event'>

## Event Trigger

Event Triggers run when an event is emitted. Perfect for background tasks, async workflows, and decoupling logic.

### The Simplest Event Trigger

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'

    export const config: EventConfig = {
      type: 'event',
      name: 'ProcessMessage',
      subscribes: ['message.sent']
    }

    export const handler: Handlers['ProcessMessage'] = async (input, { logger }) => {
      logger.info('Processing message:', input)
      // Do async work here
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      type: 'event',
      name: 'ProcessMessage',
      subscribes: ['message.sent']
    }

    const handler = async (input, { logger }) => {
      logger.info('Processing message:', input)
      // Do async work here
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "event",
        "name": "ProcessMessage",
        "subscribes": ["message.sent"]
    }

    async def handler(input, context):
        context.logger.info("Processing message:", {"input": input})
        # Do async work here
    ```
  </Tab>
</Tabs>

👉 This Step runs whenever someone emits `message.sent`.

---

### Event Handler Signature

Your handler receives two arguments:

```typescript
handler(input, ctx)
```

**`input`** is the data from the emitted event.

**`ctx`** is the same [context object](#context) all Steps get: `logger`, `emit`, `state`, `streams`, `traceId`.

---

### Config Options

All Event Steps require these:

| Property | Type | Description |
|----------|------|-------------|
| `type` | `'event'` | Marks this as an Event Step |
| `name` | `string` | Unique identifier |
| `subscribes` | `string[]` | Event topics to listen to |

Optional properties:

| Property | Type | Description |
|----------|------|-------------|
| `description` | `string` | Human-readable notes |
| `emits` | `string[]` | Events this Step can emit |
| `flows` | `string[]` | Flows this Step belongs to |
| `input` | `ZodSchema \| PydanticModel` | Validate input data |

---

### Validating Input

Just like API Steps, you can validate event data with schemas.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'ProcessOrder',
      subscribes: ['order.created'],
      input: z.object({
        orderId: z.string(),
        amount: z.number()
      })
    }

    export const handler: Handlers['ProcessOrder'] = async (input, { logger }) => {
      // input is validated and typed!
      logger.info('Processing order', { orderId: input.orderId })
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const { z } = require('zod')

    const config = {
      type: 'event',
      name: 'ProcessOrder',
      subscribes: ['order.created'],
      input: z.object({
        orderId: z.string(),
        amount: z.number()
      })
    }

    const handler = async (input, { logger }) => {
      // input is validated!
      logger.info('Processing order', { orderId: input.orderId })
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    from pydantic import BaseModel

    class OrderInput(BaseModel):
        orderId: str
        amount: float

    config = {
        "type": "event",
        "name": "ProcessOrder",
        "subscribes": ["order.created"],
        "input": OrderInput
    }

    async def handler(input, context):
        # input is validated!
        context.logger.info("Processing order", {"orderId": input.get("orderId")})
    ```
  </Tab>
</Tabs>

👉 Invalid events are logged as errors and don't trigger your handler.

---

### Chaining Events

Event Triggers can emit new events to trigger other Steps.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'

    export const config: EventConfig = {
      type: 'event',
      name: 'ProcessOrder',
      subscribes: ['order.created'],
      emits: ['order.processed']
    }

    export const handler: Handlers['ProcessOrder'] = async (input, { emit, logger }) => {
      logger.info('Processing order...')

      // Do some work...

      await emit({
        topic: 'order.processed',
        data: { orderId: input.orderId, status: 'completed' }
      })
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      type: 'event',
      name: 'ProcessOrder',
      subscribes: ['order.created'],
      emits: ['order.processed']
    }

    const handler = async (input, { emit, logger }) => {
      logger.info('Processing order...')

      // Do some work...

      await emit({
        topic: 'order.processed',
        data: { orderId: input.orderId, status: 'completed' }
      })
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
      "type": "event",
        "name": "ProcessOrder",
        "subscribes": ["order.created"],
        "emits": ["order.processed"]
    }

    async def handler(input, context):
        context.logger.info("Processing order...")

        # Do some work...

      await context.emit({
            "topic": "order.processed",
            "data": {"orderId": input.get("orderId"), "status": "completed"}
      })
    ```
  </Tab>
</Tabs>

👉 This creates a workflow: `order.created` → `ProcessOrder` → `order.processed`.

</Tab>

<Tab value='Cron'>

## Cron Trigger

Cron Triggers run on a schedule. Perfect for periodic tasks like cleanup jobs, reports, or health checks.

### The Simplest Cron Trigger

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { CronConfig, Handlers } from 'motia'

    export const config: CronConfig = {
      type: 'cron',
      name: 'DailyCleanup',
      cron: '0 0 * * *' // Every day at midnight
    }

    export const handler: Handlers['DailyCleanup'] = async ({ logger }) => {
      logger.info('Running daily cleanup')
      // Do cleanup work here
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      type: 'cron',
      name: 'DailyCleanup',
      cron: '0 0 * * *' // Every day at midnight
    }

    const handler = async ({ logger }) => {
      logger.info('Running daily cleanup')
      // Do cleanup work here
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "cron",
        "name": "DailyCleanup",
        "cron": "0 0 * * *"  # Every day at midnight
    }
  
    async def handler(context):
        context.logger.info("Running daily cleanup")
        # Do cleanup work here
    ```
  </Tab>
</Tabs>

👉 This Step runs automatically every day at midnight.

---

### Cron Handler Signature

Your handler receives one argument:

```typescript
handler(ctx)
```

**`ctx`** is the same [context object](#context) all Steps get: `logger`, `emit`, `state`, `streams`, `traceId`.

---

### Config Options

All Cron Triggers require these:

| Property | Type | Description |
|----------|------|-------------|
| `type` | `'cron'` | Marks this as a Cron Step |
| `name` | `string` | Unique identifier |
| `cron` | `string` | Cron expression for schedule |

Optional properties:

| Property | Type | Description |
|----------|------|-------------|
| `description` | `string` | Human-readable notes |
| `emits` | `string[]` | Events this Step can emit |
| `flows` | `string[]` | Flows this Step belongs to |

---

### Cron Expression Examples

| Expression | Description |
|------------|-------------|
| `* * * * *` | Every minute |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Every day at midnight |
| `0 9 * * 1` | Every Monday at 9 AM |
| `0 0 1 * *` | First day of every month |
| `*/15 * * * *` | Every 15 minutes |

👉 Use [crontab.guru](https://crontab.guru) to test and understand cron expressions.

</Tab>
</Tabs>

---

## Context – Available in All Handlers

Every handler (API Trigger, Event Trigger, or Cron Trigger) receives a `ctx` object with these tools:

| Property | Description | Example |
|----------|-------------|---------|
| `logger` | Structured logging | `logger.info('User created', { userId })` |
| `emit` | Trigger other Steps | `await emit({ topic: 'user.created', data })` |
| `state` | Persistent key-value storage | `await state.set(traceId, 'key', value)` |
| `streams` | Real-time data channels | `await streams.chat.set('room', 'msg', data)` |
| `traceId` | Unique ID for this execution | Used for tracking workflows |

---

## Common Patterns

### API Trigger → Event Trigger (Async Processing)

API endpoint triggers background work:

```typescript
// API Step - returns immediately
export const config = {
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created']
}

// Event Step - processes in background
export const config = {
  type: 'event',
  subscribes: ['order.created']
}
```

👉 Use this pattern when you want fast API responses and heavy work done asynchronously.

---

### Cron Trigger → Event Trigger (Scheduled Workflows)

Scheduled task kicks off a workflow:

```typescript
// Cron Step - runs daily
export const config = {
  type: 'cron',
  cron: '0 0 * * *',
  emits: ['daily.report.requested']
}

// Event Step - generates report
export const config = {
  type: 'event',
  subscribes: ['daily.report.requested']
}
```

👉 Use this pattern for recurring tasks like reports, cleanups, or syncs.

---

### Event Chain (Multi-Event Workflows)

Events trigger other events to create complex workflows:

```typescript
// Step 1: Validate order
export const config = {
  type: 'event',
  subscribes: ['order.created'],
  emits: ['order.validated']
}

// Step 2: Process payment
export const config = {
  type: 'event',
  subscribes: ['order.validated'],
  emits: ['payment.processed']
}

// Step 3: Send confirmation
export const config = {
  type: 'event',
  subscribes: ['payment.processed']
}
```

👉 Use this pattern to break complex logic into manageable, testable pieces.

---

## What's Next?

<Cards>
  <Card href="/docs/concepts/steps/defining-steps" title="📝 Defining Steps">
    Learn the fundamentals of creating Steps
  </Card>
  
  <Card href="/docs/development-guide/state-management" title="🔄 State Management">
    Share data between Steps
  </Card>
</Cards>
