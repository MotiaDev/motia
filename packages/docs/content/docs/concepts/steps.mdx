---
title: Steps
description: One primitive to build any backend. Simple, composable, and multi-language.
---

## One Primitive for Any Backend

A **Step** is the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:   **how it runs, when it runs, where it runs, and what it does.**

Every Step file contains two parts:

- **Config** â†’ defines when and how the Step runs, and gives it a unique `name`  
- **Handler** â†’ the function that executes your business logic  

Motia automatically discovers any file ending in `.step.ts`, `.step.js`, or `_step.py`.  
The filename tells Motia to load it, and the `name` in the `config` uniquely identifies the Step inside your system.

---

## The Simplest Example

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/hello.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

export const handler: Handlers['HelloStep'] = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};
```

</Tab>
<Tab value='Python'>

```python title="steps/hello_step.py"
config = {
    "name": "HelloStep",
    "type": "api",
    "path": "/hello",
    "method": "GET"
}

async def handler(req, ctx):
    ctx.logger.info("Hello endpoint called")
    return {"status": 200, "body": {"message": "Hello world!"}}
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/hello.step.js"
const config = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

const handler = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

ðŸ‘‰ Thatâ€™s all you need to make a running API endpoint.  
Motia will auto-discover this file and wire it into your backend.

---

## Steps Work Together: Emit + Subscribe

Steps arenâ€™t isolated. They communicate by **emitting** and **subscribing** to events.  
This is the core of how you build backends with Motia.

### Example Flow: API Step â†’ Event Step

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/send-message.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

export const handler: Handlers['SendMessage'] = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};
```

```ts title="steps/process-message.step.ts"
import { EventConfig, Handlers } from 'motia';

export const config: EventConfig = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

export const handler: Handlers['ProcessMessage'] = async (input, { logger }) => {
  logger.info('Processing message', input);
};
```
</Tab>

<Tab value='Python'>

```python title="send_message_step.py"
config = {
    "name": "SendMessage",
    "type": "api",
    "path": "/messages",
    "method": "POST",
    "emits": ["message.sent"]
}

async def handler(req, ctx):
    await ctx.emit({
        "topic": "message.sent",
        "data": {"text": req.body["text"]}
    })
    return {"status": 200, "body": {"ok": True}}
```

```python title="process_message_step.py"
config = {
    "name": "ProcessMessage",
    "type": "event",
    "subscribes": ["message.sent"]
}

async def handler(input, ctx):
    ctx.logger.info("Processing message", input)
```
</Tab>

<Tab value='JavaScript'>

```js title="steps/send-message.step.js"
const config = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

const handler = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};

module.exports = { config, handler };
```

```js title="steps/process-message.step.js"
const config = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

const handler = async (input, { logger }) => {
  logger.info('Processing message', input);
};

module.exports = { config, handler };
```
</Tab>
</Tabs>

ðŸ‘‰ With just two files, you have an **API endpoint** that triggers an **event-driven workflow**.  

---

## Triggers

Every Step has a `type` that defines **how it triggers**:

| Type | When it runs | Use case |
|------|--------------|----------|
| `api` | HTTP request | REST APIs, webhooks |
| `event` | Event emitted | Background jobs, workflows |
| `cron` | Schedule | Cleanup, reports, reminders |

<Tabs items={['API', 'Event', 'Cron']}>
  <Tab value="API">

### API Trigger

Runs when an HTTP request hits the path.

**Example:**

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'

    export const config: ApiRouteConfig = {
      name: 'GetUser',
      type: 'api',
      path: '/users/:id',
      method: 'GET'
    }

    export const handler: Handlers['GetUser'] = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })
      return { status: 200, body: { id: userId, name: 'John' } }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'GetUser',
      type: 'api',
      path: '/users/:id',
      method: 'GET'
    }

    const handler = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })
      return { status: 200, body: { id: userId, name: 'John' } }
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "GetUser",
        "type": "api",
        "path": "/users/:id",
        "method": "GET"
    }

    async def handler(req, ctx):
        user_id = req.get("pathParams", {}).get("id")
        ctx.logger.info("Getting user", {"userId": user_id})
        return {"status": 200, "body": {"id": user_id, "name": "John"}}
    ```
  </Tab>
</Tabs>

**Config:**

| Property | Description |
|----------|-------------|
| `name` | Unique identifier |
| `type` | Set to `'api'` |
| `path` | URL path (supports `:params`) |
| `method` | GET, POST, PUT, DELETE |
| `bodySchema` | Validate request body |

**Handler:** `handler(req, ctx)`

- `req` - Request with `body`, `headers`, `pathParams`, `queryParams`
- `ctx` - Context with `logger`, `emit`, `state`, `streams`, `traceId`
- Returns `{ status, body, headers? }`

</Tab>

  <Tab value="Event">

### Event Trigger

Runs when an event is emitted. Use for background tasks.

**Example:**

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'

    export const config: EventConfig = {
      name: 'ProcessMessage',
      type: 'event',
      subscribes: ['message.sent'],
      emits: ['message.processed']
    }

    export const handler: Handlers['ProcessMessage'] = async (input, { logger, emit }) => {
      logger.info('Processing message:', input)
      await emit({ topic: 'message.processed', data: input })
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'ProcessMessage',
      type: 'event',
      subscribes: ['message.sent'],
      emits: ['message.processed']
    }

    const handler = async (input, { logger, emit }) => {
      logger.info('Processing message:', input)
      await emit({ topic: 'message.processed', data: input })
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "ProcessMessage",
        "type": "event",
        "subscribes": ["message.sent"],
        "emits": ["message.processed"]
    }

    async def handler(input, ctx):
        ctx.logger.info("Processing message:", {"input": input})
        await ctx.emit({"topic": "message.processed", "data": input})
    ```
  </Tab>
</Tabs>

**Config:**

| Property | Description |
|----------|-------------|
| `name` | Unique identifier |
| `type` | Set to `'event'` |
| `subscribes` | Event topics to listen to |
| `emits` | Event topics to emit |
| `input` | Validate input data |

**Handler:** `handler(input, ctx)`

- `input` - Data from the emitted event
- `ctx` - Context with `logger`, `emit`, `state`, `streams`, `traceId`

</Tab>

  <Tab value="Cron">

### Cron Trigger

Runs on a schedule. Use for periodic tasks.

**Example:**

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { CronConfig, Handlers } from 'motia'

    export const config: CronConfig = {
      name: 'DailyCleanup',
      type: 'cron',
      cron: '0 0 * * *'
    }

    export const handler: Handlers['DailyCleanup'] = async ({ logger }) => {
      logger.info('Running daily cleanup')
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'DailyCleanup',
      type: 'cron',
      cron: '0 0 * * *'
    }

    const handler = async ({ logger }) => {
      logger.info('Running daily cleanup')
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "DailyCleanup",
        "type": "cron",
        "cron": "0 0 * * *"
    }
  
    async def handler(ctx):
        ctx.logger.info("Running daily cleanup")
    ```
  </Tab>
</Tabs>

**Config:**

| Property | Description |
|----------|-------------|
| `name` | Unique identifier |
| `type` | Set to `'cron'` |
| `cron` | Cron expression |

**Handler:** `handler(ctx)`

- `ctx` - Context with `logger`, `emit`, `state`, `streams`, `traceId`

**Common schedules:**

| Expression | Runs |
|------------|------|
| `* * * * *` | Every minute |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Daily at midnight |
| `0 9 * * 1` | Monday at 9 AM |

ðŸ‘‰ Use [crontab.guru](https://crontab.guru) to build expressions.

</Tab>
</Tabs>

---

## Context Object

Every handler receives a `ctx` object with these tools:

| Property | Description |
|----------|-------------|
| `logger` | Structured logging (`info`, `warn`, `error`) |
| `emit` | Trigger other Steps by emitting events |
| `state` | Persistent key-value storage |
| `streams` | Real-time data channels for clients |
| `traceId` | Unique ID for tracing requests & workflows |

---

## Core Functionality

### State â€“ Persistent Data

Key-value storage shared across Steps and workflows.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
await state.set(traceId, 'preferences', { theme: 'dark' });
const prefs = await state.get(traceId, 'preferences');
```

</Tab>
<Tab value='Python'>

```python
await context.state.set(context.trace_id, "preferences", {"theme": "dark"})
prefs = await context.state.get(context.trace_id, "preferences")
```

</Tab>
<Tab value='JavaScript'>

```js
await state.set(traceId, 'preferences', { theme: 'dark' });
const prefs = await state.get(traceId, 'preferences');
```

</Tab>
</Tabs>

ðŸ‘‰ [Learn more about State Management â†’](/docs/development-guide/state-management)

### Logging â€“ Structured & Contextual

For debugging, monitoring, and observability.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
logger.info('Processing user', { userId: '123' });
```

</Tab>
<Tab value='Python'>

```python
context.logger.info("Processing user", {"userId": "123"})
```

</Tab>
<Tab value='JavaScript'>

```js
logger.info('Processing user', { userId: '123' });
```

</Tab>
</Tabs>

ðŸ‘‰ [Learn more about Observability â†’](/docs/development-guide/observability)

### Streams â€“ Real-Time Data

Push updates directly to connected clients.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
await streams.chat.set('room-123', 'msg-456', { text: 'Hello!' });
```

</Tab>
<Tab value='Python'>

```python
await context.streams.chat.set("room-123", "msg-456", {"text": "Hello!"})
```

</Tab>
<Tab value='JavaScript'>

```js
await streams.chat.set('room-123', 'msg-456', { text: 'Hello!' });
```

</Tab>
</Tabs>

ðŸ‘‰ [Learn more about Streams â†’](/docs/development-guide/streams)

---

## Infrastructure Configuration

For **Event Steps**, you can customize infrastructure settings to control handler resources and queue behavior. This is optional â€“ Motia provides sensible defaults for all settings.

### Handler Configuration

Control the compute resources allocated to your Step handler:

| Property | Type | Range | Default | Description |
|----------|------|-------|---------|-------------|
| `ram` | `number` | 128 - 10240 MB | 512 MB | Memory allocated to the handler |
| `timeout` | `number` | 1 - 900 seconds | 30 seconds | Maximum execution time |
| `cpu` | `number` | - | Auto-calculated | CPU allocation (proportional to RAM) |

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/process-video.step.ts"
import { EventConfig, Handlers } from 'motia';

export const config: EventConfig = {
  name: 'ProcessVideo',
  type: 'event',
  subscribes: ['video.uploaded'],
  infrastructure: {
    handler: {
      ram: 2048,
      timeout: 300
    }
  }
};

export const handler: Handlers['ProcessVideo'] = async (input, { logger }) => {
  logger.info('Processing video with extended resources');
};
```

</Tab>
<Tab value='Python'>

```python title="steps/process_video_step.py"
config = {
    "name": "ProcessVideo",
    "type": "event",
    "subscribes": ["video.uploaded"],
    "infrastructure": {
        "handler": {
            "ram": 2048,
            "timeout": 300
        }
    }
}

async def handler(input, ctx):
    ctx.logger.info("Processing video with extended resources")
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/process-video.step.js"
const config = {
  name: 'ProcessVideo',
  type: 'event',
  subscribes: ['video.uploaded'],
  infrastructure: {
    handler: {
      ram: 2048,
      timeout: 300
    }
  }
};

const handler = async (input, { logger }) => {
  logger.info('Processing video with extended resources');
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

### Queue Configuration

Control how events are queued and retried:

| Property | Type | Options | Default | Description |
|----------|------|---------|---------|-------------|
| `type` | `string` | `standard`, `fifo` | `standard` | Queue type |
| `maxRetries` | `number` | â‰¥ 0 | 3 | Number of retry attempts on failure |
| `visibilityTimeout` | `number` | seconds | 900 | Time before message becomes visible again |
| `delaySeconds` | `number` | 0 - 900 | 0 | Delay before processing the message |

#### Retry Configuration Example

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/send-email.step.ts"
import { EventConfig, Handlers } from 'motia';

export const config: EventConfig = {
  name: 'SendEmail',
  type: 'event',
  subscribes: ['email.requested'],
  infrastructure: {
    handler: {
      timeout: 10
    },
    queue: {
      maxRetries: 5,
      visibilityTimeout: 60
    }
  }
};

export const handler: Handlers['SendEmail'] = async (input, { logger }) => {
  logger.info('Sending email with retry support');
};
```

</Tab>
<Tab value='Python'>

```python title="steps/send_email_step.py"
config = {
    "name": "SendEmail",
    "type": "event",
    "subscribes": ["email.requested"],
    "infrastructure": {
        "handler": {
            "timeout": 10
        },
        "queue": {
            "maxRetries": 5,
            "visibilityTimeout": 60
        }
    }
}

async def handler(input, ctx):
    ctx.logger.info("Sending email with retry support")
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/send-email.step.js"
const config = {
  name: 'SendEmail',
  type: 'event',
  subscribes: ['email.requested'],
  infrastructure: {
    handler: {
      timeout: 10
    },
    queue: {
      maxRetries: 5,
      visibilityTimeout: 60
    }
  }
};

const handler = async (input, { logger }) => {
  logger.info('Sending email with retry support');
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

#### FIFO Queue Example

FIFO queues guarantee exactly-once processing and maintain message order within a group:

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/process-order.step.ts"
import { z } from 'zod';
import { EventConfig, Handlers } from 'motia';

const inputSchema = z.object({
  orderId: z.string(),
  customerId: z.string()
});

export const config: EventConfig = {
  name: 'ProcessOrder',
  type: 'event',
  subscribes: ['order.created'],
  input: inputSchema,
  infrastructure: {
    queue: {
      type: 'fifo'
    }
  }
};

export const handler: Handlers['ProcessOrder'] = async (input, { logger }) => {
  logger.info('Processing order in sequence', { orderId: input.orderId });
};
```

</Tab>
<Tab value='Python'>

```python title="steps/process_order_step.py"
config = {
    "name": "ProcessOrder",
    "type": "event",
    "subscribes": ["order.created"],
    "input": {
        "type": "object",
        "properties": {
            "orderId": {"type": "string"},
            "customerId": {"type": "string"}
        },
        "required": ["orderId", "customerId"]
    },
    "infrastructure": {
        "queue": {
            "type": "fifo"
        }
    }
}

async def handler(input, ctx):
    ctx.logger.info("Processing order in sequence", {"orderId": input["orderId"]})
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/process-order.step.js"
const config = {
  name: 'ProcessOrder',
  type: 'event',
  subscribes: ['order.created'],
  input: {
    type: 'object',
    properties: {
      orderId: { type: 'string' },
      customerId: { type: 'string' }
    },
    required: ['orderId', 'customerId']
  },
  infrastructure: {
    queue: {
      type: 'fifo'
    }
  }
};

const handler = async (input, { logger }) => {
  logger.info('Processing order in sequence', { orderId: input.orderId });
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

#### Emitting to FIFO Queues

When emitting events to FIFO queues, you must pass a `messageGroupId` as part of the emit options. This ID determines which message group the event belongs to, ensuring ordered processing within that group:

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/create-order.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'CreateOrder',
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created']
};

export const handler: Handlers['CreateOrder'] = async (req, { emit, logger }) => {
  const { orderId, customerId } = req.body;
  
  await emit({
    topic: 'order.created',
    data: { orderId, customerId },
    messageGroupId: customerId
  });
  
  logger.info('Order created and emitted to FIFO queue', { orderId, customerId });
  return { status: 200, body: { orderId } };
};
```

</Tab>
<Tab value='Python'>

```python title="steps/create_order_step.py"
config = {
    "name": "CreateOrder",
    "type": "api",
    "path": "/orders",
    "method": "POST",
    "emits": ["order.created"]
}

async def handler(req, ctx):
    order_id = req.body["orderId"]
    customer_id = req.body["customerId"]
    
    await ctx.emit({
        "topic": "order.created",
        "data": {"orderId": order_id, "customerId": customer_id},
        "messageGroupId": customer_id
    })
    
    ctx.logger.info("Order created and emitted to FIFO queue", {
        "orderId": order_id,
        "customerId": customer_id
    })
    return {"status": 200, "body": {"orderId": order_id}}
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/create-order.step.js"
const config = {
  name: 'CreateOrder',
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created']
};

const handler = async (req, { emit, logger }) => {
  const { orderId, customerId } = req.body;
  
  await emit({
    topic: 'order.created',
    data: { orderId, customerId },
    messageGroupId: customerId
  });
  
  logger.info('Order created and emitted to FIFO queue', { orderId, customerId });
  return { status: 200, body: { orderId } };
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

**When to use `messageGroupId` in emit:**

- **Ordered processing**: When you need to ensure events are processed in the order they were emitted within a specific group
- **Exactly-once delivery**: FIFO queues with message groups guarantee that each message is delivered exactly once
- **Logical grouping**: Group related events together (e.g., all events for a specific customer, order, or user)

For FIFO queues, the `messageGroupId` is required when calling `emit()`. Without it, the message will fail validation.

### Validation Rules

Motia validates your infrastructure configuration:

- **Visibility Timeout Rule**: `visibilityTimeout` must be greater than `handler.timeout` to prevent premature message redelivery
- **FIFO Queue Rule**: When `queue.type` is `fifo`, `messageGroupId` must be passed explicitly when calling `emit()`

### Default Values

If you don't specify infrastructure settings, Motia uses these defaults:

```ts
{
  handler: {
    ram: 512,
    timeout: 30
  },
  queue: {
    type: 'standard',
    maxRetries: 3,
    visibilityTimeout: 900,
    delaySeconds: 0
  }
}
```

---

## Remember

- **Steps are just files.** Export a `config` and `handler`.  
- Motia auto-discovers and connects them.  
- Combine Steps with **emit + subscribe** to build APIs, workflows, background jobs, or entire systems.  

---

## What's Next?

ðŸ‘‰ [Build your first app â†’](/docs/getting-started/build-your-first-motia-app)
