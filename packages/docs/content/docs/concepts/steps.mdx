---
title: Steps
description: One primitive to build any backend. Simple, composable, and multi-language.
---

## One Primitive for Any Backend

A **Step** is the core primitive in Motia. Instead of juggling separate frameworks for APIs, background jobs, queues, or workflows, you define everything in one place:   **how it runs, when it runs, where it runs, and what it does.**

Every Step file contains two parts:

- **Config** â†’ defines when and how the Step runs, and gives it a unique `name`  
- **Handler** â†’ the function that executes your business logic  

Motia automatically discovers any file ending in `.step.ts`, `.step.js`, or `_step.py`.  
The filename tells Motia to load it, and the `name` in the `config` uniquely identifies the Step inside your system.

---

## The Simplest Example

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/hello.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

export const handler: Handlers['HelloStep'] = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};
```

</Tab>
<Tab value='Python'>

```python title="steps/hello_step.py"
config = {
    "name": "HelloStep",
    "type": "api",
    "path": "/hello",
    "method": "GET"
}

async def handler(req, ctx):
    ctx.logger.info("Hello endpoint called")
    return {"status": 200, "body": {"message": "Hello world!"}}
```

</Tab>
<Tab value='JavaScript'>

```js title="steps/hello.step.js"
const config = {
  name: 'HelloStep',
  type: 'api',
  path: '/hello',
  method: 'GET'
};

const handler = async (req, { logger }) => {
  logger.info('Hello endpoint called');
  return { status: 200, body: { message: 'Hello world!' } };
};

module.exports = { config, handler };
```

</Tab>
</Tabs>

ðŸ‘‰ Thatâ€™s all you need to make a running API endpoint.  
Motia will auto-discover this file and wire it into your backend.

---

## Steps Work Together: Emit + Subscribe

Steps arenâ€™t isolated. They communicate by **emitting** and **subscribing** to events.  
This is the core of how you build backends with Motia.

### Example Flow: API Step â†’ Event Step

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts title="steps/send-message.step.ts"
import { ApiRouteConfig, Handlers } from 'motia';

export const config: ApiRouteConfig = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

export const handler: Handlers['SendMessage'] = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};
```

```ts title="steps/process-message.step.ts"
import { EventConfig, Handlers } from 'motia';

export const config: EventConfig = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

export const handler: Handlers['ProcessMessage'] = async (input, { logger }) => {
  logger.info('Processing message', input);
};
```
</Tab>

<Tab value='Python'>

```python title="send_message_step.py"
config = {
    "name": "SendMessage",
    "type": "api",
    "path": "/messages",
    "method": "POST",
    "emits": ["message.sent"]
}

async def handler(req, ctx):
    await ctx.emit({
        "topic": "message.sent",
        "data": {"text": req.body["text"]}
    })
    return {"status": 200, "body": {"ok": True}}
```

```python title="process_message_step.py"
config = {
    "name": "ProcessMessage",
    "type": "event",
    "subscribes": ["message.sent"]
}

async def handler(input, ctx):
    ctx.logger.info("Processing message", input)
```
</Tab>

<Tab value='JavaScript'>

```js title="steps/send-message.step.js"
const config = {
  name: 'SendMessage',
  type: 'api',
  path: '/messages',
  method: 'POST',
  emits: ['message.sent']
};

const handler = async (req, { emit }) => {
  await emit({
    topic: 'message.sent',
    data: { text: req.body.text }
  });
  return { status: 200, body: { ok: true } };
};

module.exports = { config, handler };
```

```js title="steps/process-message.step.js"
const config = {
  name: 'ProcessMessage',
  type: 'event',
  subscribes: ['message.sent']
};

const handler = async (input, { logger }) => {
  logger.info('Processing message', input);
};

module.exports = { config, handler };
```
</Tab>
</Tabs>

ðŸ‘‰ With just two files, you have an **API endpoint** that triggers an **event-driven workflow**.  

---

## Triggers

Every Step has a `type` that defines **how it triggers**. Change the type, and the same pattern works for different use cases.

| Type     | When it runs                 | Example use case |
|----------|------------------------------|------------------|
| `api`    | On an HTTP request           | REST endpoints, webhooks |
| `event`  | When an event is emitted     | Event-driven workflows |
| `cron`   | On a schedule                | Nightly jobs, reminders |

---

### API Trigger

Exposes HTTP endpoints. When a request hits the path, your handler runs.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'

    export const config: ApiRouteConfig = {
      name: 'GetUser',
      type: 'api',
      path: '/users/:id',
      method: 'GET'
    }

    export const handler: Handlers['GetUser'] = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })

      return {
        status: 200,
        body: { id: userId, name: 'John Doe' }
      }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'GetUser',
      type: 'api',
      path: '/users/:id',
      method: 'GET'
    }

    const handler = async (req, { logger }) => {
      const userId = req.pathParams.id
      logger.info('Getting user', { userId })

      return {
        status: 200,
        body: { id: userId, name: 'John Doe' }
      }
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "GetUser",
        "type": "api",
        "path": "/users/:id",
        "method": "GET"
    }

    async def handler(req, context):
        user_id = req.get("pathParams", {}).get("id")
        context.logger.info("Getting user", {"userId": user_id})

        return {
            "status": 200,
            "body": {"id": user_id, "name": "John Doe"}
        }
    ```
  </Tab>
</Tabs>

**Handler:** `handler(req, ctx)`

- **`req`** - HTTP request with `body`, `headers`, `pathParams`, `queryParams`
- **`ctx`** - Context object (see below)
- **Returns** - `{ status, body, headers? }`

**Config:**

| Property | Required | Description |
|----------|----------|-------------|
| `name` | Yes | Unique identifier |
| `type` | Yes | Set to `'api'` |
| `path` | Yes | URL path (supports `:params`) |
| `method` | Yes | HTTP method (GET, POST, PUT, DELETE) |
| `bodySchema` | No | Validate request body (Zod/Pydantic) |
| `middleware` | No | Pre-handler functions |

---

### Event Trigger

Runs when an event is emitted. Use for background tasks and async workflows.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'

    export const config: EventConfig = {
      name: 'ProcessMessage',
      type: 'event',
      subscribes: ['message.sent']
    }

    export const handler: Handlers['ProcessMessage'] = async (input, { logger }) => {
      logger.info('Processing message:', input)
      // Do async work here
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'ProcessMessage',
      type: 'event',
      subscribes: ['message.sent']
    }

    const handler = async (input, { logger }) => {
      logger.info('Processing message:', input)
      // Do async work here
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "ProcessMessage",
        "type": "event",
        "subscribes": ["message.sent"]
    }

    async def handler(input, context):
        context.logger.info("Processing message:", {"input": input})
        # Do async work here
    ```
  </Tab>
</Tabs>

**Handler:** `handler(input, ctx)`

- **`input`** - Data from the emitted event
- **`ctx`** - Context object (see below)

**Config:**

| Property | Required | Description |
|----------|----------|-------------|
| `name` | Yes | Unique identifier |
| `type` | Yes | Set to `'event'` |
| `subscribes` | Yes | Event topics to listen to |
| `input` | No | Validate input data (Zod/Pydantic) |

---

### Cron Trigger

Runs on a schedule. Use for periodic tasks like cleanup jobs or reports.

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { CronConfig, Handlers } from 'motia'

    export const config: CronConfig = {
      name: 'DailyCleanup',
      type: 'cron',
      cron: '0 0 * * *' // Every day at midnight
    }

    export const handler: Handlers['DailyCleanup'] = async ({ logger }) => {
      logger.info('Running daily cleanup')
      // Do cleanup work here
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      name: 'DailyCleanup',
      type: 'cron',
      cron: '0 0 * * *' // Every day at midnight
    }

    const handler = async ({ logger }) => {
      logger.info('Running daily cleanup')
      // Do cleanup work here
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "name": "DailyCleanup",
        "type": "cron",
        "cron": "0 0 * * *"  # Every day at midnight
    }
  
    async def handler(context):
        context.logger.info("Running daily cleanup")
        # Do cleanup work here
    ```
  </Tab>
</Tabs>

**Handler:** `handler(ctx)`

- **`ctx`** - Context object (see below)

**Config:**

| Property | Required | Description |
|----------|----------|-------------|
| `name` | Yes | Unique identifier |
| `type` | Yes | Set to `'cron'` |
| `cron` | Yes | Cron expression (e.g., `'0 0 * * *'`) |

Common cron expressions:

| Expression | Runs... |
|------------|---------|
| `* * * * *` | Every minute |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Every day at midnight |
| `0 9 * * 1` | Every Monday at 9 AM |
| `*/15 * * * *` | Every 15 minutes |

ðŸ‘‰ Use [crontab.guru](https://crontab.guru) to build cron expressions.

---

## Context Object

Every handler receives a `ctx` object with these tools:

| Property | Description |
|----------|-------------|
| `logger` | Structured logging (`info`, `warn`, `error`) |
| `emit` | Trigger other Steps by emitting events |
| `state` | Persistent key-value storage |
| `streams` | Real-time data channels for clients |
| `traceId` | Unique ID for tracing requests & workflows |

---

## Core Functionality

### State â€“ Persistent Data

Key-value storage shared across Steps and workflows.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
await state.set(traceId, 'preferences', { theme: 'dark' });
const prefs = await state.get(traceId, 'preferences');
```

</Tab>
<Tab value='Python'>

```python
await context.state.set(context.trace_id, "preferences", {"theme": "dark"})
prefs = await context.state.get(context.trace_id, "preferences")
```

</Tab>
<Tab value='JavaScript'>

```js
await state.set(traceId, 'preferences', { theme: 'dark' });
const prefs = await state.get(traceId, 'preferences');
```

</Tab>
</Tabs>

### Logging â€“ Structured & Contextual

For debugging, monitoring, and observability.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
logger.info('Processing user', { userId: '123' });
```

</Tab>
<Tab value='Python'>

```python
context.logger.info("Processing user", {"userId": "123"})
```

</Tab>
<Tab value='JavaScript'>

```js
logger.info('Processing user', { userId: '123' });
```

</Tab>
</Tabs>

### Streams â€“ Real-Time Data

Push updates directly to connected clients.

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```ts
await streams.chat.set('room-123', 'msg-456', { text: 'Hello!' });
```

</Tab>
<Tab value='Python'>

```python
await context.streams.chat.set("room-123", "msg-456", {"text": "Hello!"})
```

</Tab>
<Tab value='JavaScript'>

```js
await streams.chat.set('room-123', 'msg-456', { text: 'Hello!' });
```

</Tab>
</Tabs>

---

## Remember

- **Steps are just files.** Export a `config` and `handler`.  
- Motia auto-discovers and connects them.  
- Combine Steps with **emit + subscribe** to build APIs, workflows, background jobs, or entire systems.  

---

## Whatâ€™s Next?

ðŸ‘‰ [Build your first app â†’](/docs/getting-started/build-your-first-app)
