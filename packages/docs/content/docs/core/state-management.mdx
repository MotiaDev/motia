---
title: State Management
---

State management is at the heart of Motia's workflow engine. Our powerful yet simple system gives you everything you need to maintain state across your flows and steps:

‚ú® Zero configuration with in-memory storage out of the box <br />
üîå Flexible storage options including Memory, File, and Redis adapters <br />
üßπ Automatic state cleanup with TTL support <br />
üîí Built-in isolation to keep your flow states separate and secure <br />

## Storage Adapters

Motia comes with three storage adapters out of the box:

- üìÅ File (Default)
- üíæ Memory 
- ‚ö° Redis

In order to use a different adapter, you can specify the adapter name in a `config.yml` file located in the root of your project:

<Folder name="my-project" defaultOpen>
  <File name="config.yml" />
  <Folder name="steps" defaultOpen>
    <File name="step-1.ts" />
    <File name="step-2.ts" />
  </Folder>
</Folder>

<Tabs items={['File', 'Memory', 'Redis']}>
  <Tab>
    <Callout type="info">Default, no configuration needed, state is stored into .motia/motia.state.json in your project root</Callout>
  </Tab>
  <Tab>
    ```yaml
    # config.yml
    state:
      adapter: memory
    ```
  </Tab>
  <Tab>
    ```yaml
    # config.yml
    state:
      adapter: redis
      host: localhost
      port: 6379
      password: optional
      ttl: 3600  # Optional: Time in seconds before state expires
    ```
  </Tab>
</Tabs>

## Core Concepts

### State Manager Properties

| Method | Parameters | Return Type | Description |
|--------|------------|-------------|-------------|
| `get` | `traceId: string, key: string` | `Promise<T \| null>` | Retrieves a value by key from the state store. Returns null if not found. Type `T` is inferred from usage. |
| `set` | `traceId: string, key: string, value: T` | `Promise<void>` | Stores a value in the state store. Type `T` can be any serializable value. |
| `delete` | `traceId: string, key: string` | `Promise<void>` | Removes a specific key-value pair from the state store. |
| `clear` | `traceId: string` | `Promise<void>` | Removes all state data associated with the given traceId. |
| `cleanup` | none | `Promise<void>` | Performs maintenance operations like removing expired state data. Implementation depends on adapter type. |

### State Scope

Each flow execution gets a unique state object identified by a `traceId` (a UUID). This ensures:

| Feature | Description |
|---------|-------------|
| Isolation | Each flow execution has its own state space |
| Boundaries | Clear separation between different flows |
| Cleanup | Automatic state cleanup after flow completion |


### State Structure

```typescript
// Example state structure
{
  "motia:state:{traceId}": {
    "booking": {
      "customer": { ... },
      "venue": { ... }
    },
    "payment": {
      "status": "pending",
      "amount": 100
    }
  }
}
```

<Callout type="info">
  You can access the state manager in any step through the context argument injected into your [step handler](/docs/core/steps/defining-steps#handler).
</Callout>

## Using State in Steps

<Tabs items={['TypeScript', 'Python', 'Ruby']}>
  <Tab>
    ```typescript
    import { StepHandler } from '@motiadev/core'

    export const handler: StepHandler<typeof config> = async (input, { state }) => {
      // Store state
      await state.set('booking', {
        customer: input.customer,
        venue: input.venue,
      })

      // Retrieve state
      const booking = await state.get<BookingData>('booking')

      // Delete specific state
      await state.delete('booking')

      // Clear all state for this flow
      await state.clear()
    }
    ```
  </Tab>
  
  <Tab>
    ```python
    async def handler(input, ctx):
        # Store state
        await ctx.state.set('booking', {
            'customer': input.customer,
            'venue': input.venue
        })

        # Retrieve state
        booking = await ctx.state.get('booking')

        # Delete specific state
        await ctx.state.delete('booking')

        # Clear all state
        await ctx.state.clear()
    ```
  </Tab>
  
  <Tab>
    ```ruby
    def handler(input, ctx)
      # Store state
      ctx.state.set('booking', {
        customer: input.customer,
        venue: input.venue
      })

      # Retrieve state
      booking = ctx.state.get('booking')

      # Delete specific state
      ctx.state.delete('booking')

      # Clear all state
      ctx.state.clear()
    end
    ```
  </Tab>
</Tabs>

### Custom State Adapters

```typescript
import { StateAdapter } from '@motiadev/core'

class CustomStateAdapter extends StateAdapter {
  async get<T>(traceId: string, key: string): Promise<T | null> {
    // Implementation
  }

  async set<T>(traceId: string, key: string, value: T): Promise<void> {
    // Implementation
  }

  async delete(traceId: string, key: string): Promise<void> {
    // Implementation
  }

  async clear(traceId: string): Promise<void> {
    // Implementation
  }

  async cleanup(): Promise<void> {
    // Implementation
  }
}
```

## Best Practices

<Steps>
  <Step>
    #### Namespacing

    Use dot notation to organize related state data hierarchically:

    <Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
      <Tab>
        ```typescript
        // Good - Organized hierarchically
        await state.set('booking.customer', customerData)
        await state.set('booking.venue', venueData)
        await state.set('payment.status', 'pending')

        // Avoid - Flat structure
        await state.set('customer', customerData)
        await state.set('venue', venueData)
        await state.set('paymentStatus', 'pending')
        ```
      </Tab>
      <Tab>
        ```javascript
        // Good - Organized hierarchically
        await state.set('booking.customer', customerData)
        await state.set('booking.venue', venueData)
        await state.set('payment.status', 'pending')

        // Avoid - Flat structure
        await state.set('customer', customerData)
        await state.set('venue', venueData)
        await state.set('paymentStatus', 'pending')
        ```
      </Tab>
      <Tab>
        ```python
        # Good - Organized hierarchically
        await state.set('booking.customer', customer_data)
        await state.set('booking.venue', venue_data)
        await state.set('payment.status', 'pending')

        # Avoid - Flat structure
        await state.set('customer', customer_data)
        await state.set('venue', venue_data)
        await state.set('payment_status', 'pending')
        ```
      </Tab>
      <Tab>
        ```ruby
        # Good - Organized hierarchically
        state.set('booking.customer', customer_data)
        state.set('booking.venue', venue_data)
        state.set('payment.status', 'pending')

        # Avoid - Flat structure
        state.set('customer', customer_data)
        state.set('venue', venue_data)
        state.set('payment_status', 'pending')
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step>
    #### Type Safety

    Define types for your state data to ensure consistency:

    <Tabs items={['TypeScript', 'Python', 'Ruby']}>
      <Tab>
        ```typescript
        interface CustomerData {
          name: string;
          email: string;
        }

        interface VenueData {
          id: string;
          capacity: number;
        }

        type BookingState = {
          customer: CustomerData;
          venue: VenueData;
          status: 'pending' | 'confirmed';
        }

        const booking = await state.get<BookingState>('booking')
        ```
      </Tab>
      <Tab>
        ```python
        from dataclasses import dataclass
        from typing import Literal

        @dataclass
        class CustomerData:
            name: str
            email: str

        @dataclass
        class VenueData:
            id: str
            capacity: int

        @dataclass
        class BookingState:
            customer: CustomerData
            venue: VenueData
            status: Literal['pending', 'confirmed']

        booking = await state.get('booking')
        ```
      </Tab>
      <Tab>
        ```ruby
        # Using Sorbet for type checking
        class CustomerData < T::Struct
          const :name, String
          const :email, String
        end

        class VenueData < T::Struct
          const :id, String
          const :capacity, Integer
        end

        class BookingState < T::Struct
          const :customer, CustomerData
          const :venue, VenueData
          const :status, T.enum([:pending, :confirmed])
        end

        booking = state.get('booking')
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step>
    #### Cleanup

    Always clean up state when you're done with it:

    <Tabs items={['TypeScript', 'JavaScript', 'Python', 'Ruby']}>
    <Tab>
      ```typescript
      export const handler: StepHandler<typeof config> = async (input, { state }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete('booking.customer')
          // Or clean everything
          await state.clear()
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>
    <Tab>
      ```javascript
      export const handler = async (input, { state }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete('booking.customer')
          // Or clean everything
          await state.clear()
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>
    <Tab>
      ```python
      async def handler(input, ctx):
          try:
              await process_booking(input)
              # Clean up specific keys
              await ctx.state.delete('booking.customer')
              # Or clean everything
              await ctx.state.clear()
          except Exception as error:
              # Handle errors
              pass
      ```
    </Tab>
    <Tab>
      ```ruby
      def handler(input, ctx)
        begin
          process_booking(input)
          # Clean up specific keys
          ctx.state.delete('booking.customer')
          # Or clean everything
          ctx.state.clear()
        rescue => error
          # Handle errors
        end
      end
      ```
      </Tab>
    </Tabs>
  </Step>
</Steps>

### Performance Considerations

| Consideration | Description |
|--------------|-------------|
| Batch Operations | Group related state updates and use atomic operations when possible |
| State Size | Keep state data minimal and consider access patterns |
| TTL Management | Set appropriate TTLs based on flow duration and error recovery needs |

## Debugging

### Inspecting State

<Tabs items={['Memory', 'File', 'Redis']}>
  <Tab>
    State is only available during runtime in the Node.js process memory.
  </Tab>
  <Tab>
    ```bash
    # View state file contents
    motia state list
    ```
  </Tab>
  <Tab>
    ```bash
    # List all state keys
    redis-cli KEYS "motia:state:*"

    # Get specific state
    redis-cli GET "motia:state:{traceId}:booking"
    ```
  </Tab>
</Tabs>

### Common Issues

| Issue | Troubleshooting Steps |
|-------|---------------------|
| State Not Found | - Verify state adapter configuration<br/>- Check TTL expiration (Redis)<br/>- Ensure file permissions (File adapter)<br/>- Verify traceId |
| Persistence | - Memory adapter: State is lost on process restart<br/>- File adapter: Check file write permissions<br/>- Redis: Verify connection and persistence settings |
| Concurrent Access | - Memory/File: Limited concurrent flow support<br/>- Redis: Use atomic operations and implement retry logic |
