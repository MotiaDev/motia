---
sidebar_position: 5
title: Logging
---

## Overview

Motia provides a powerful logging system that works across different runtime environments. The logging system:

- Provides real-time log streaming
- Supports multiple log levels
- Includes contextual information
- Integrates with Motia Workbench

## Core Concepts

### Log Levels

Motia supports four standard log levels:

| Log Type | Description |
| -------- | ----------- |
| info     | General information about step execution, workflow progress, and successful operations |
| error    | Critical issues, exceptions, failed operations, and system errors |
| debug    | Detailed debugging information and diagnostic data for troubleshooting |
| warn     | Potential issues, edge cases, or situations requiring attention |

### Log Context

Each log entry automatically includes:

<DescriptionTable
  type={{
    timestamp: {
      description: 'When the log was generated',
      type: 'string',
    },
    traceId: {
      description: 'Unique identifier for the workflow execution',
      type: 'string',
    },
    flows: {
      description: 'Array of flow names this step belongs to',
      type: 'string[]',
    },
    file: {
      description: 'Source file generating the log',
      type: 'string',
    },
    level: {
      description: 'Log level',
      type: 'string',
    },
    msg: {
      description: 'Log message',
      type: 'string',
    },
  }}
/>


## Using Logging in Steps

### TypeScript/JavaScript

<Tabs items={['TS', 'JS', 'Python', 'Ruby']}>
  <Tab value='TS'>
    ```typescript
    import { EventConfig, StepHandler } from '@motiadev/core'

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      // Basic logging
      logger.info('Starting payment processing')

      // Logging with context and structured data
      logger.info('Payment processed successfully', {
        amount: input.amount,
        currency: input.currency,
      })

      // Error logging with enhanced context
      try {
        await processPayment(input)
      } catch (error) {
        logger.error('Payment processing failed', {
          error: error.message,
          code: error.code,
          stack: error.stack,
          input: JSON.stringify(input)
        })
      }

      // Debug logging with enhanced details
      logger.debug('Payment processing details', {
        rawInput: input,
        timestamp: Date.now(),
      })

      // Warning logging with thresholds
      if (input.amount > 10000) {
        logger.warn('Large payment amount detected', {
          amount: input.amount,
          threshold: 10000,
          currency: input.currency
        })
      }
    }
    ```
  </Tab>
  <Tab value='JS'>
    ```javascript
    export const handler = async (input, { logger }) => {
      // Basic logging
      logger.info('Processing payment')

      // Logging with context
      logger.info('Payment processed', {
        amount: input.amount,
        currency: input.currency,
      })

      // Error logging
      try {
        await processPayment(input)
      } catch (error) {
        logger.error('Payment failed', {
          error: error.message,
          code: error.code,
        })
      }

      // Debug logging
      logger.debug('Payment details', {
        rawInput: input,
        timestamp: Date.now(),
      })

      // Warning logging
      if (input.amount > 10000) {
        logger.warn('Large payment detected', {
          amount: input.amount,
        })
      }
    }
    ```
  </Tab>
  <Tab value='Python'>
    ```python
    async def handler(input, ctx):
        # Basic logging
        ctx.logger.info('Processing payment')

        # Logging with context
        ctx.logger.info('Payment processed', {
            'amount': input.amount,
            'currency': input.currency
        })

        # Error logging
        try:
            await process_payment(input)
        except Exception as error:
            ctx.logger.error('Payment failed', {
                'error': str(error)
            })

        # Debug logging
        ctx.logger.debug('Payment details', {
            'raw_input': input.__dict__,
            'timestamp': time.time()
        })
    ```
  </Tab>
  <Tab value='Ruby'>
    ```ruby
    def handler(input, ctx)
      # Basic logging
      ctx.logger.info('Processing payment')

      # Logging with context
      ctx.logger.info('Payment processed', {
        amount: input.amount,
        currency: input.currency
      })

      # Error logging
      begin
        process_payment(input)
      rescue StandardError => error
        ctx.logger.error('Payment failed', {
          error: error.message
        })
      end

      # Debug logging
      ctx.logger.debug('Payment details', {
        raw_input: input.to_h,
        timestamp: Time.now.to_i
      })
    end
    ```
  </Tab>
</Tabs>

## Best Practices

### Consistent Log Levels

<Tabs items={['info', 'error', 'debug', 'warn']}>
  <Tab value='info'>
  **Use `info` for**:
  
  - Step start/completion
  - Important business events
  - State changes
  - Successful operations
  - Key workflow transitions
  - API calls and responses
  - Data transformations
  </Tab>
  <Tab value='error'>
  **Use `error` for**:
  
  - Exceptions
  - API failures
  - Business rule violations
  - Data integrity issues
  - Security violations
  - System resource exhaustion
  - Critical configuration issues
  </Tab>
  <Tab value='debug'>
  **Use `debug` for**:
  
  - Detailed execution data
  - Input/output values
  - Performance metrics
  </Tab>
  <Tab value='warn'>
  **Use `warn` for**:
  
  - Potential issues
  - Deprecated features
  - Resource warnings
  </Tab>
</Tabs>

### Structured Logging

```typescript
// Good - Structured and searchable
logger.info('Payment processed', {
  paymentId: '123',
  amount: 100,
  status: 'success',
})

// Avoid - Harder to parse and search
logger.info(`Payment ${paymentId} processed: amount=${amount}`)
```

### Context Propagation

```typescript
export const handler: StepHandler<typeof config> = async (input, { logger, traceId }) => {
  // Add business context
  logger.info('Starting payment processing', {
    businessUnit: input.businessUnit,
    region: input.region,
    correlationId: input.correlationId,
  })

  try {
    const result = await processPayment(input)

    // Log success with result context
    logger.info('Payment successful', {
      transactionId: result.transactionId,
      processingTime: result.duration,
    })
  } catch (error) {
    // Log error with full context
    logger.error('Payment failed', {
      error: error.message,
      code: error.code,
      attempt: error.attempt,
      failureType: error.type,
    })
  }
}
```

### Performance Logging

```typescript
export const handler: StepHandler<typeof config> = async (input, { logger }) => {
  const startTime = performance.now()

  // Process payment
  const result = await processPayment(input)

  // Log performance metrics
  logger.info('Payment processing completed', {
    duration: performance.now() - startTime,
    steps: result.steps.length,
    dataSize: JSON.stringify(input).length,
    memoryUsage: process.memoryUsage().heapUsed,
    timestamp: new Date().toISOString()
  })
}
```

## Debugging

### Log Filtering

Motia Workbench provides powerful log filtering capabilities:

- Filter by log level
- Filter by flow
- Filter by time range
- Search by content

### Common Patterns

1. **Transaction Tracing**

```typescript
logger.info('Starting transaction', {
  type: 'START',
  transactionId,
})

// ... processing ...

logger.info('Transaction complete', {
  type: 'END',
  transactionId,
  duration,
})
```

2. **Error Correlation**

```typescript
try {
  await riskyOperation()
} catch (error) {
  logger.error('Operation failed', {
    error: error.message,
    stack: error.stack,
    correlationId: input.correlationId,
  })
}
```

## Monitoring

### Metrics to Track

- Log volume by level
- Error rates and patterns
- Warning frequencies
- Performance metrics
- Resource utilization
- Business metrics

### Log Analysis

```typescript
// Track error rates
logger.error('API failure', {
  endpoint: '/api/payment',
  statusCode: 500,
  retryCount: 3,
  errorType: 'TIMEOUT',
  latency: 5000,
  region: 'us-west-2'
})

// Monitor performance
logger.info('Operation complete', {
  operationType: 'payment',
  duration: 1500,
  resourceUsage: {
    memory: process.memoryUsage(),
    cpu: process.cpuUsage(),
  },
  timestamp: new Date().toISOString(),
  environment: process.env.NODE_ENV
})
```
