---
title: Long-Running Workflows
description: Build workflows that can run for hours, days, or even weeks
---

Some workflows take time. Really long time.

Maybe you're waiting for a payment to clear. Or a shipment to arrive. Or someone to approve something. These workflows might run for minutes, hours, days, or even weeks.

Motia handles this by letting you **save progress as you go**. When something takes a while, you save where you are, and pick it back up later.

## How It Works

Long-running workflows in Motia work like this:

1. **Save progress after each step** - Store data in state
2. **Steps talk through events** - Each step does its part and triggers the next
3. **Use webhooks to continue** - External systems can restart your workflow right where it left off

No magic. Just save your progress, emit events, and continue when you're ready.

---

## Key Ideas

| Concept | What It Means |
|---------|---------------|
| **Save as you go** | After each meaningful step, save your progress to state |
| **Events connect steps** | Steps don't wait for each other - they emit events |
| **Webhooks for re-entry** | Create API steps that external systems can call to continue your workflow |
| **You're in control** | You decide what to save and when |

<Callout type="info">
Every time you save to state, that's a checkpoint. If something crashes, you pick up from your last checkpoint.
</Callout>

---

## Real Example: Order Processing

Let's build an order workflow that handles payment and shipping. It might take days to complete.

### Step 1: Create Order

An API receives the order and saves it immediately:

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="src/create-order.step.ts"
import { ApiRouteConfig, Handlers } from 'motia'

export const config: ApiRouteConfig = {
  name: 'CreateOrder',
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created'],
  flows: ['orders']
}

export const handler: Handlers['CreateOrder'] = async (req, { state, emit, logger }) => {
  const orderId = crypto.randomUUID()
  
  const order = {
    id: orderId,
    items: req.body.items,
    total: req.body.total,
    status: 'pending',
    currentStep: 'created',
    completedSteps: ['created'],
    createdAt: new Date().toISOString()
  }
  
  // Save immediately - this is our first checkpoint
  await state.set('orders', orderId, order)
  
  logger.info('Order created', { orderId })
  
  // Kick off the next step
  await emit({ 
    topic: 'order.created', 
    data: { orderId } 
  })
  
  return { status: 201, body: order }
}
```

</Tab>
<Tab value='Python'>

```python title="src/create_order.step.py"
import uuid
from datetime import datetime

config = {
    "name": "CreateOrder",
    "type": "api",
    "path": "/orders",
    "method": "POST",
    "emits": ["order.created"],
    "flows": ["orders"]
}

async def handler(req, ctx):
    order_id = str(uuid.uuid4())
    
    order = {
        "id": order_id,
        "items": req["body"]["items"],
        "total": req["body"]["total"],
        "status": "pending",
        "current_step": "created",
        "completed_steps": ["created"],
        "created_at": datetime.now().isoformat()
    }
    
    # Save immediately - this is our first checkpoint
    await ctx.state.set("orders", order_id, order)
    
    ctx.logger.info("Order created", {"orderId": order_id})
    
    # Kick off the next step
    await ctx.emit({
        "topic": "order.created",
        "data": {"orderId": order_id}
    })
    
    return {"status": 201, "body": order}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="src/create-order.step.js"
const config = {
  name: 'CreateOrder',
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created'],
  flows: ['orders']
}

const handler = async (req, { state, emit, logger }) => {
  const orderId = crypto.randomUUID()
  
  const order = {
    id: orderId,
    items: req.body.items,
    total: req.body.total,
    status: 'pending',
    currentStep: 'created',
    completedSteps: ['created'],
    createdAt: new Date().toISOString()
  }
  
  // Save immediately - this is our first checkpoint
  await state.set('orders', orderId, order)
  
  logger.info('Order created', { orderId })
  
  // Kick off the next step
  await emit({ 
    topic: 'order.created', 
    data: { orderId } 
  })
  
  return { status: 201, body: order }
}

module.exports = { config, handler }
```

</Tab>
</Tabs>

ðŸ‘‰ **Notice:** We save the order right away with `currentStep` and `completedSteps`. This tracks where we are.

### Step 2: Process Payment

This step runs in the background and might take a while:

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="src/process-payment.step.ts"
import { EventConfig, Handlers } from 'motia'

export const config: EventConfig = {
  name: 'ProcessPayment',
  type: 'event',
  subscribes: ['order.created'],
  emits: ['payment.completed'],
  flows: ['orders']
}

export const handler: Handlers['ProcessPayment'] = async (input, { state, emit, logger }) => {
  const { orderId } = input
  
  const order = await state.get('orders', orderId)
  
  if (!order) {
    logger.error('Order not found', { orderId })
    return
  }
  
  // Skip if we already did this (makes it safe to retry)
  if (order.completedSteps.includes('payment')) {
    logger.info('Payment already done', { orderId })
    return
  }
  
  // Update state before processing
  order.currentStep = 'payment'
  await state.set('orders', orderId, order)
  
  try {
    // Process payment (this might take a while)
    const paymentId = await processPayment(order)
    
    // Save the result
    order.status = 'paid'
    order.paymentId = paymentId
    order.completedSteps.push('payment')
    order.currentStep = 'awaiting_shipment'
    await state.set('orders', orderId, order)
    
    logger.info('Payment completed', { orderId, paymentId })
    
    await emit({ 
      topic: 'payment.completed', 
      data: { orderId } 
    })
    
  } catch (error) {
    order.lastError = error.message
    await state.set('orders', orderId, order)
    logger.error('Payment failed', { orderId, error: error.message })
  }
}

async function processPayment(order) {
  // Your payment logic here
  return `pay_${Date.now()}`
}
```

</Tab>
<Tab value='Python'>

```python title="src/process_payment.step.py"
import time

config = {
    "name": "ProcessPayment",
    "type": "event",
    "subscribes": ["order.created"],
    "emits": ["payment.completed"],
    "flows": ["orders"]
}

async def handler(input, ctx):
    order_id = input["orderId"]
    
    order = await ctx.state.get("orders", order_id)
    
    if not order:
        ctx.logger.error("Order not found", {"orderId": order_id})
        return
    
    # Skip if we already did this (makes it safe to retry)
    if "payment" in order["completed_steps"]:
        ctx.logger.info("Payment already done", {"orderId": order_id})
        return
    
    # Update state before processing
    order["current_step"] = "payment"
    await ctx.state.set("orders", order_id, order)
    
    try:
        # Process payment (this might take a while)
        payment_id = f"pay_{int(time.time() * 1000)}"
        
        # Save the result
        order["status"] = "paid"
        order["payment_id"] = payment_id
        order["completed_steps"].append("payment")
        order["current_step"] = "awaiting_shipment"
        await ctx.state.set("orders", order_id, order)
        
        ctx.logger.info("Payment completed", {"orderId": order_id, "paymentId": payment_id})
        
        await ctx.emit({
            "topic": "payment.completed",
            "data": {"orderId": order_id}
        })
        
    except Exception as e:
        order["last_error"] = str(e)
        await ctx.state.set("orders", order_id, order)
        ctx.logger.error("Payment failed", {"orderId": order_id, "error": str(e)})
```

</Tab>
<Tab value='JavaScript'>

```javascript title="src/process-payment.step.js"
const config = {
  name: 'ProcessPayment',
  type: 'event',
  subscribes: ['order.created'],
  emits: ['payment.completed'],
  flows: ['orders']
}

const handler = async (input, { state, emit, logger }) => {
  const { orderId } = input
  
  const order = await state.get('orders', orderId)
  
  if (!order) {
    logger.error('Order not found', { orderId })
    return
  }
  
  // Skip if we already did this (makes it safe to retry)
  if (order.completedSteps.includes('payment')) {
    logger.info('Payment already done', { orderId })
    return
  }
  
  // Update state before processing
  order.currentStep = 'payment'
  await state.set('orders', orderId, order)
  
  try {
    // Process payment (this might take a while)
    const paymentId = `pay_${Date.now()}`
    
    // Save the result
    order.status = 'paid'
    order.paymentId = paymentId
    order.completedSteps.push('payment')
    order.currentStep = 'awaiting_shipment'
    await state.set('orders', orderId, order)
    
    logger.info('Payment completed', { orderId, paymentId })
    
    await emit({ 
      topic: 'payment.completed', 
      data: { orderId } 
    })
    
  } catch (error) {
    order.lastError = error.message
    await state.set('orders', orderId, order)
    logger.error('Payment failed', { orderId, error: error.message })
  }
}

module.exports = { config, handler }
```

</Tab>
</Tabs>

ðŸ‘‰ **Key points:**
- Check if we already did this step (idempotency)
- Save before doing work
- Save after doing work
- If it fails, save the error

### Step 3: Webhook for Shipping

Sometimes you need to wait for an external system. Like a shipping company calling you back days later.

Create an API step as a webhook:

<Tabs items={['TypeScript', 'Python', 'JavaScript']}>
<Tab value='TypeScript'>

```typescript title="src/shipping-webhook.step.ts"
import { ApiRouteConfig, Handlers } from 'motia'

export const config: ApiRouteConfig = {
  name: 'ShippingWebhook',
  type: 'api',
  path: '/webhooks/shipping',
  method: 'POST',
  emits: ['order.shipped'],
  flows: ['orders']
}

export const handler: Handlers['ShippingWebhook'] = async (req, { state, emit, logger }) => {
  const { orderId, trackingNumber, carrier } = req.body
  
  // Load the order
  const order = await state.get('orders', orderId)
  
  if (!order) {
    return { status: 404, body: { error: 'Order not found' } }
  }
  
  // Make sure we're at the right step
  if (order.currentStep !== 'awaiting_shipment') {
    logger.warn('Order not ready for shipping', { 
      orderId, 
      currentStep: order.currentStep 
    })
    return { status: 400, body: { error: 'Order not ready' } }
  }
  
  // Update with shipping info
  order.status = 'shipped'
  order.trackingNumber = trackingNumber
  order.carrier = carrier
  order.shippedAt = new Date().toISOString()
  order.completedSteps.push('shipped')
  order.currentStep = 'complete'
  
  await state.set('orders', orderId, order)
  
  logger.info('Order shipped', { orderId, trackingNumber })
  
  // Continue the workflow
  await emit({ 
    topic: 'order.shipped', 
    data: { orderId } 
  })
  
  return { status: 200, body: { success: true } }
}
```

</Tab>
<Tab value='Python'>

```python title="src/shipping_webhook.step.py"
from datetime import datetime

config = {
    "name": "ShippingWebhook",
    "type": "api",
    "path": "/webhooks/shipping",
    "method": "POST",
    "emits": ["order.shipped"],
    "flows": ["orders"]
}

async def handler(req, ctx):
    body = req["body"]
    order_id = body["orderId"]
    tracking_number = body["trackingNumber"]
    carrier = body["carrier"]
    
    # Load the order
    order = await ctx.state.get("orders", order_id)
    
    if not order:
        return {"status": 404, "body": {"error": "Order not found"}}
    
    # Make sure we're at the right step
    if order["current_step"] != "awaiting_shipment":
        ctx.logger.warn("Order not ready for shipping", {
            "orderId": order_id,
            "currentStep": order["current_step"]
        })
        return {"status": 400, "body": {"error": "Order not ready"}}
    
    # Update with shipping info
    order["status"] = "shipped"
    order["tracking_number"] = tracking_number
    order["carrier"] = carrier
    order["shipped_at"] = datetime.now().isoformat()
    order["completed_steps"].append("shipped")
    order["current_step"] = "complete"
    
    await ctx.state.set("orders", order_id, order)
    
    ctx.logger.info("Order shipped", {"orderId": order_id, "trackingNumber": tracking_number})
    
    # Continue the workflow
    await ctx.emit({
        "topic": "order.shipped",
        "data": {"orderId": order_id}
    })
    
    return {"status": 200, "body": {"success": True}}
```

</Tab>
<Tab value='JavaScript'>

```javascript title="src/shipping-webhook.step.js"
const config = {
  name: 'ShippingWebhook',
  type: 'api',
  path: '/webhooks/shipping',
  method: 'POST',
  emits: ['order.shipped'],
  flows: ['orders']
}

const handler = async (req, { state, emit, logger }) => {
  const { orderId, trackingNumber, carrier } = req.body
  
  // Load the order
  const order = await state.get('orders', orderId)
  
  if (!order) {
    return { status: 404, body: { error: 'Order not found' } }
  }
  
  // Make sure we're at the right step
  if (order.currentStep !== 'awaiting_shipment') {
    logger.warn('Order not ready for shipping', { 
      orderId, 
      currentStep: order.currentStep 
    })
    return { status: 400, body: { error: 'Order not ready' } }
  }
  
  // Update with shipping info
  order.status = 'shipped'
  order.trackingNumber = trackingNumber
  order.carrier = carrier
  order.shippedAt = new Date().toISOString()
  order.completedSteps.push('shipped')
  order.currentStep = 'complete'
  
  await state.set('orders', orderId, order)
  
  logger.info('Order shipped', { orderId, trackingNumber })
  
  // Continue the workflow
  await emit({ 
    topic: 'order.shipped', 
    data: { orderId } 
  })
  
  return { status: 200, body: { success: true } }
}

module.exports = { config, handler }
```

</Tab>
</Tabs>

ðŸ‘‰ **The pattern:** External system calls your webhook â†’ You load state â†’ Update and continue

---

## Recovery Patterns

Things go wrong. Here's how to handle it.

### Pattern 1: Find and Fix Stuck Workflows

Use a cron job to detect workflows that got stuck:

<Tabs items={['TypeScript', 'Python']}>
<Tab value='TypeScript'>

```typescript title="src/recover-orders.step.ts"
import { CronConfig, Handlers } from 'motia'

export const config: CronConfig = {
  name: 'RecoverOrders',
  type: 'cron',
  cron: '*/10 * * * *', // Every 10 minutes
  flows: ['orders']
}

export const handler: Handlers['RecoverOrders'] = async (_, { state, emit, logger }) => {
  const orders = await state.getGroup('orders')
  const now = Date.now()
  const stuckTime = 30 * 60 * 1000 // 30 minutes
  
  for (const order of orders) {
    // Find orders that haven't moved in a while
    if (order.status !== 'complete') {
      const lastUpdate = new Date(order.updatedAt || order.createdAt).getTime()
      
      if (now - lastUpdate > stuckTime) {
        logger.warn('Found stuck order, retrying', { 
          orderId: order.id, 
          currentStep: order.currentStep 
        })
        
        // Re-trigger based on where it's stuck
        if (order.currentStep === 'payment') {
          await emit({ topic: 'order.created', data: { orderId: order.id } })
        }
      }
    }
  }
}
```

</Tab>
<Tab value='Python'>

```python title="src/recover_orders.step.py"
from datetime import datetime

config = {
    "name": "RecoverOrders",
    "type": "cron",
    "cron": "*/10 * * * *",  # Every 10 minutes
    "flows": ["orders"]
}

async def handler(_, ctx):
    orders = await ctx.state.get_group("orders")
    now = datetime.now().timestamp() * 1000
    stuck_time = 30 * 60 * 1000  # 30 minutes
    
    for order in orders:
        # Find orders that haven't moved in a while
        if order["status"] != "complete":
            last_update = datetime.fromisoformat(
                order.get("updated_at", order["created_at"])
            ).timestamp() * 1000
            
            if now - last_update > stuck_time:
                ctx.logger.warn("Found stuck order, retrying", {
                    "orderId": order["id"],
                    "currentStep": order["current_step"]
                })
                
                # Re-trigger based on where it's stuck
                if order["current_step"] == "payment":
                    await ctx.emit({
                        "topic": "order.created",
                        "data": {"orderId": order["id"]}
                    })
```

</Tab>
</Tabs>

### Pattern 2: Make Steps Safe to Run Twice

Always check if you already did something:

```typescript
// âœ… Good - safe to run multiple times
if (order.completedSteps.includes('payment')) {
  logger.info('Already done, skipping')
  return
}

// âœ… Also check external systems
if (order.paymentId) {
  const payment = await checkPaymentStatus(order.paymentId)
  if (payment.status === 'completed') {
    // Mark as complete and continue
    order.completedSteps.push('payment')
    await state.set('orders', order.id, order)
    return
  }
}
```

### Pattern 3: Track Everything

Keep good records in your state:

```typescript
const order = {
  id: orderId,
  // Business data
  items: [...],
  total: 99.99,
  
  // Workflow tracking
  status: 'pending',
  currentStep: 'created',
  completedSteps: ['created'],
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  lastError: null
}
```

---

## Summary

Building long-running workflows in Motia:

1. **Save progress** after each step with `state.set()`
2. **Use events** to connect steps without tight coupling
3. **Create webhooks** (API steps) for external systems to call back
4. **Check completion** before doing work (idempotency)
5. **Use cron jobs** to find and fix stuck workflows
6. **Track everything** in state for debugging

Your workflow might take weeks to complete, but as long as you save progress and use webhooks to continue, Motia handles it smoothly.

---

## Related

- [State Management â†’](/docs/development-guide/state-management)
- [Adapters â†’](/docs/development-guide/adapters)
- [Flows â†’](/docs/development-guide/flows)
- [Observability â†’](/docs/development-guide/observability)
