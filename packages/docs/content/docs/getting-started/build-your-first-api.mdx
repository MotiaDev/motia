---
title: Build Your First API in Motia (TypeScript)
description: Learn how to create, connect, and extend your first API using Motia’s workflow engine in TypeScript. This guide covers key concepts, best practices, and how APIs fit into Motia’s polyglot architecture.
---

APIs are one of the core concepts of Motia because they define how your backend talks to external applications. In Motia, creating an API is just one kind of Step you can add to your workflow, but it’s a powerful starting point because you can immediately connect it to other Steps, events, and services without extra setup.

This guide will walk you through the concepts behind building your first API in Motia using TypeScript. You’ll learn what an API Step is, how requests are handled inside Motia, and how to connect your API to other parts of your backend.

## Motia Concepts You’ll Use

Before we go into building your first API, let’s get familiar with the core concepts you’ll work with in Motia:

- **Step** – The building block of all Motia logic. Unlike traditional functions, Steps can be triggered by HTTP requests, events, or schedules.
- **API Step** – Exposes HTTP endpoints with built-in TypeScript validation and connects directly to your workflow.
- **Flow** – Groups related Steps together for visual organization and debugging in the Workbench.
- **State** – Built-in key-value storage that's automatically traced and shared across all Steps.
- **Event Step** – Handles asynchronous processing triggered by other Steps—no separate queue system needed.

## API Anatomy section

Every API Step in Motia consists of two parts that work together to create a complete HTTP endpoint:

| Component | Type | Description |
|-----------|------|-------------|
| **`ApiRouteConfig`** | `object` | Configuration object that defines the HTTP endpoint structure, including the path, method, validation schemas, and event connections. This is where you declaratively specify what your API looks like and how it connects to other parts of your workflow. |
| **`Handlers[StepName]`** | `function` | The handler function that contains your business logic. It receives the HTTP request and Motia's context (logger, emit, state, traceId) and returns an HTTP response. This is where your actual application logic lives. |

## Creating a Pet Store API Project

Now that you understand the core parts of an API Step, let’s put that knowledge into practice by building a real API project.
In this example, we’ll create a Pet Store API using Motia and TypeScript. This project will start with a single endpoint for creating a pet and then expand to include additional features such as retrieving pet details, listing pets, and emitting events for asynchronous processing.

## Project Setup
Before we write our first API Step, let’s set up a new Motia project. We’ll use the Pet Store API example so you can follow along and run everything locally.

### Create a New Project
Create a new Motia project called pet-store-api using the command below: 

```bash
npx motia@latest create -i
```
During setup:
- Language → Select TypeScript (this lets us use type safety and Zod validation).
- Project name → Type pet-store-api (or choose your own).

Once setup completes, navigate into the new directory:
```bash
cd pet-store-api 
```

### Run the Development Server Workbench
```bash 
npx motia dev
```
This should start the development server at:  http://localhost:3000. You should see the Motia Workbench interface showing:

- Interactive flow visualization
- Endpoint testing interface
- Real-time logs and traces

![Endpoint Visualization](./../img/pet-store-api-view.png)
![Flow Visualization in Workbench](./../img/pet-store-workbench.png)

## Step 1: Create Your First API Endpoint
Now that you have the Workbench running, let's create your first API endpoint.By default, a `default` API is created when you initialize a motia project. For our pet store project we will create a new file in the steps folder.

### Creating the Pet Registration API

We'll start by building an API endpoint that allows users to register new pets and optionally place food orders. This endpoint will demonstrate key concepts like request validation, external API integration, and response handling.

Create a new file in your project:

In Motia, every API endpoint is defined as an "API Step." Let's create our first one.

**File:** `steps/01-api.step.ts`

```typescript 
import { ApiRouteConfig, Handlers } from 'motia'
import { z } from 'zod'
import { petStoreService } from '../services/pet-store'

export const config: ApiRouteConfig = {
  type: 'api',
  name: 'ApiTrigger',
  description: 'Pet registration API that creates a new pet and optionally processes a food order',
  
  /**
   * The flows this step belongs to, will be available in Workbench
   */
  flows: ['pet-registration],

  method: 'POST',
  path: '/pet-registration',
  
  /**
   * Expected request body for type checking and documentation
   */
  bodySchema: z.object({
    pet: z.object({
      name: z.string(),
      photoUrl: z.string(),
    }),
    foodOrder: z
      .object({
        id: z.string(),
        quantity: z.number(),
      })
      .optional(),
  }),

  /**
   * Expected response body for type checking and documentation
   */
  responseSchema: {
    200: z.object({
      message: z.string(),
      traceId: z.string(),
    }),
  },

  /**
   * This API Step emits events to topic `process-food-order`
   */
  emits: ['process-food-order'],

  /**
   * We're using virtual subscribes to virtually connect noop step
   * to this step.
   *
   * Noop step is defined in noop.step.ts
   */
  virtualSubscribes: ['/pet-registration'],
}

export const handler: Handlers['ApiTrigger'] = async (req, { logger, emit, traceId }) => {
  /**
   * Avoid usage of console.log, use logger instead
   */
  logger.info('Step 01 – Processing API Step', { body: req.body })

  const { pet, foodOrder } = req.body

  const newPetRecord = await petStoreService.createPet(pet)

  /**
   * Emit events to the topics to process asynchronously
   */
  if (foodOrder) {
    await emit({
      topic: 'process-food-order',
      data: {
        ...foodOrder,
        petId: newPetRecord.id,
      },
    })
  }

  /**
   * Return data back to the client
   */
  return {
    status: 200,
    body: {
      traceId,
      message: 'Your pet has been registered and your order is being processed',
    },
  }
}
```

Now let's break down the important parts of this API Step and understand how each part works.

#### The Configuration Object
The `config` object tells Motia everything it needs to know about your API endpoint:

```typescript
export const config: ApiRouteConfig = {
  type: 'api',
  name: 'ApiTrigger',
  method: 'POST',
  path: '/pet-registration',
  // ...
}
```
The type: 'api' field identifies this as an API Step, not an event or cron step. Motia uses this to know that it should create an HTTP endpoint. The name field is important because it connects your configuration to your handler function. See how the handler uses Handlers['ApiTrigger'].
The method and path work together to define your endpoint. This creates a POST endpoint at /pet-registration, so clients will send requests to http://localhost:3000/pet-registration.

#### Request Validation with Zod
The bodySchema is where TypeScript and runtime validation happen:

```typescript
bodySchema: z.object({
  pet: z.object({
    name: z.string(),
    photoUrl: z.string(),
  }),
  foodOrder: z.object({
    id: z.string(),
    quantity: z.number(),
  }).optional(),
})
```
This schema does two things. First, it provides TypeScript types for your handler function, when you access req.body.pet.name, TypeScript knows it's a string. Second, it validates incoming requests at runtime. If someone sends invalid data, Motia automatically returns a 400 error before your handler even runs.
The .optional() on foodOrder means clients can include it or leave it out. This flexibility is common in real APIs where some data is required and some is optional.

#### The Handler Function
The handler is where your business logic lives:
```typescript 
export const handler: Handlers['ApiTrigger'] = async (req, { logger, emit, traceId }) => {
  const { pet, foodOrder } = req.body
  // ...
}
```
Notice how the handler receives two parameters. The first is req, which contains your validated request data. The second is a context object with Motia utilities like logger for structured logging and emit for triggering other parts of your workflow.
The destructuring of req.body is safe here because Zod already validated that pet exists and has the right structure. TypeScript knows the exact shape of this data.

#### External API Integration
This line shows how to integrate with external services:

```typescript 
const newPetRecord = await petStoreService.createPet(pet)
```

The petStoreService is a separate module that handles the HTTP call to the external Petstore API. This separation keeps your API Step focused on handling the request and response, while the service handles the details of external communication.

### Response Structure
Every handler must return a response object:
```typescript 
return {
  status: 200,
  body: {
    traceId,
    message: 'Your pet has been registered and your order is being processed',
  },
}
```
Reload your development server you should see an endpoint `pet-registration` added and you can make a post request to register a pet.

![Pet Registration API Workflow](./../img/pet-registration.gif)

### Adding More APIs - section to add more API endpoints like get pets by id, get users by id etc once the above has been validated