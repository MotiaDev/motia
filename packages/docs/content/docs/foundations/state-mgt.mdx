---
title: "State Management"
description: "Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication."
---

Motia gives you a simple but powerful system for handling state across your flows. Whether you're passing data between steps or persisting temporary results, the built-in state manager helps you do it cleanly and effectively.

State management enables you to store and share data across steps in your Motia workflows. 

Think of it as a persistent memory that follows your workflow execution from start to finish.


## States in your workflows
Each workflow execution gets a unique `traceId` (UUID) that serves as its state namespace. This means:

- Multiple workflows can run simultaneously without interfering with each other
- Each workflow's state is completely isolated
- State cleanup is simple and predictable

```typescript
// Workflow A (traceId: "abc-123")
await state.set("abc-123", 'user', { name: 'Alice' });

// Workflow B (traceId: "def-456") 
await state.set("def-456", 'user', { name: 'Bob' });

// These don't interfere with each other
```

## Using State in Steps

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    ```typescript
    import { Handlers } from 'motia'

    interface BookingData {
      customer: { name: string; email: string };
      venue: { id: string; name: string };
    }

    export const handler: Handlers['StepName'] = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set<BookingData>(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get<BookingData>(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```

  </Tab>

  <Tab label="JavaScript">
    ```javascript
    import { Handlers } from 'motia'

    export const handler: Handlers['StepName'] = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```

  </Tab>

  <Tab label="Python">
    ```python
    async def handler(input, ctx): # ctx is the context object
        trace_id = ctx.trace_id # Access traceId from context

        # Store state (using traceId as scope)
        await ctx.state.set(trace_id, 'booking', {
            'customer': input.get("customer"),
            'venue': input.get("venue")
        })

        # Retrieve state (using traceId as scope)
        booking = await ctx.state.get(trace_id, 'booking')

        # Delete specific state (using traceId as scope)
        await ctx.state.delete(trace_id, 'booking')

        # Clear all state (using traceId as scope)
        await ctx.state.clear(trace_id)
    ```
  </Tab>
</Tabs>

<Callout type="info" title="Scope parameter in state manager">
You can access the state manager within any step through the `ctx` (context) argument, which is automatically injected into your step handler. 

While `traceId` from `ctx.traceId` is the recommended scope for flow isolation, remember that you can use any string as the scope parameter in state methods for more advanced state management scenarios.
</Callout>

## State Methods

| Method    | Parameters                             | Return Type          | Description                                                                                                                                                                                   |
| --------- | -------------------------------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `get`     | `scope: string, key: string`           | `Promise<T \| null>` | Retrieves a value associated with the given `key` and `scope` from the state store. Returns `null` if the key is not found. The type `T` is inferred based on how you use the returned value. |
| `set`     | `scope: string, key: string, value: T` | `Promise<void>`      | Stores a `value` associated with the given `key` and `scope` in the state store. The type `T` can be any serializable JavaScript/JSON value.                                                  |
| `delete`  | `scope: string, key: string`           | `Promise<void>`      | Removes the key-value pair associated with the given `key` and `scope` from the state store.                                                                                                  |
| `clear`   | `scope: string`                        | `Promise<void>`      | Removes **all** state data associated with the provided `scope`. This is useful for cleaning up state for a specific scope.                                                                   |
| `cleanup` | _(None)_                               | `Promise<void>`      | Performs periodic maintenance tasks, such as removing expired state data (TTL cleanup). The actual implementation depends on the configured state adapter.                                    |


<Callout title="State Scope Required" type="info">
  State manager methods (`get`, `set`, `delete`, `clear`) require a **scope string** as the first parameter.  

  In most cases, you'll use the `traceId`, automatically available as `ctx.traceId`, to ensure **flow-level isolation**.  
  However, you can technically use **any string value** as the scope to group and manage state data across flows or contexts.  

  **Tip:** Using `traceId` is the recommended and most common practice for isolating state per flow execution.

  Each flow execution in Motia.dev is assigned a unique `traceId` (a UUID). Using this `traceId` as the scope for state management provides automatic isolation
</Callout>


## Inspecting State

<Tabs items={['Memory', 'File', 'Redis']}>
  <Tab label="Memory">
    > State is only available during runtime in the Node.js process memory. You cannot inspect memory state directly outside of a running step execution. Use logging within your steps to output state values for debugging purposes.
  </Tab>
  <Tab label="File">
    To inspect state stored in the **File Adapter**, you can directly view the contents of the state file using the Motia CLI:

    ```bash
    # View state file contents
    motia state list
    ```

    This command will output the entire state file (motia.state.json) content in JSON format to your console, allowing you to examine the stored state data.

  </Tab>
  <Tab label="Redis">
    To inspect state stored in **Redis Adapter**, you can use the `redis-cli` command-line tool to interact with your Redis server:

    ```bash
    # List all state keys (under the motia:state prefix)
    redis-cli KEYS "motia:state:*"

    # Get specific state for a given traceId and key
    redis-cli GET "motia:state:{traceId}:booking"
    ```
    **Note:** Replace `{traceId}` in the `redis-cli GET` command with the actual `traceId` of the flow execution you are debugging. Replace `booking` with the specific `key` you want to inspect.

  </Tab>
</Tabs>
<Callout type="warn" title="State Manager best practices">
Don't forget to checkout the [best practices](/docs/foundations/happy-practices#best-practices-of-using-state-manager) of using State Manger when writing Motia apps.
</Callout>

## Storage Adapters
In Motia, storage adapters define how and where your workflowâ€™s state is stored. Motia support three storage adapters:
1. File (Default): Persists state to a JSON file in your project (`.motia/motia.state.json`). No configuration needed for basic use.
2. Memory: Stores state in-memory. Fastest option, but state is not persistent across server restarts. Useful for development and non-critical data.
3. Redis: Leverages Redis for persistent and scalable state storage. Ideal for production environments and flows requiring high availability and data durability.

<Tabs items={['File Adapter', 'Memory Adapter', 'Redis Adapter']}>

  <Tab label="File Adapter">
    **File Adapter (Default)**

    Default adapter with no configuration required.  
    State is persisted to `.motia/motia.state.json` in your project root.

    > Ideal for local development or simple persistent use cases.
  </Tab>

  <Tab label="Memory Adapter">
    ```yaml title="config.yml"
    state:
      adapter: memory
    ```

    > State is stored in-memory and will be **lost** when the dev server restarts.  
    > Best suited for development and testing where persistence is not required.
  </Tab>

  <Tab label="Redis Adapter">
    ```yaml title="config.yml"
    state:
      adapter: redis
      host: localhost  # Redis server host (e.g., 'localhost' or IP address)
      port: 6379        # Redis server port (default: 6379)
      password: optional # Redis password (if required)
      ttl: 3600         # Optional: Time-To-Live in seconds (e.g., 3600 = 1 hour)
    ```

    > Recommended for production environments. Requires a running Redis server. The `ttl` option allows **automatic expiration** of state entries, helping manage Redis storage effectively.
  </Tab>

</Tabs>

## Custom State Adapters
If none of the built-in adapters (`in-memory`, `file-based`, or `Redis`) meet your needs then you can write your own adapter. For example, if you want to:
	-	Store state in a database (like MongoDB or Postgres),
	-	Use a custom encryption mechanism,
	-	Send state to an external API,
  
then, you'll have to write your own adapter. 

Motia exposes a `StateAdapter` base class. You extend this class and implement its required methods.
To configure a different state adapter, modify the `config.yml` file in your project root:
```bash
my-project/
â”œâ”€â”€ config.yml
â””â”€â”€ steps/
    â”œâ”€â”€ step-1.ts
    â””â”€â”€ step-2.ts
```
```typescript title="Custom State Adapter Example"
import { StateAdapter } from 'motia'

class CustomStateAdapter extends StateAdapter {
  async get<T>(traceId: string, key: string): Promise<T | null> {
    // Implementation
    return null
  }

  async set<T>(traceId: string, key: string, value: T): Promise<void> {
    // Implementation
  }

  async delete(traceId: string, key: string): Promise<void> {
    // Implementation
  }

  async clear(traceId: string): Promise<void> {
    // Implementation
  }

  async cleanup(): Promise<void> {
    // Implementation
  }
}
```

## Next Steps
<Cards>
  <Card
    title="ðŸš€ Deployments"
    description="Learn how to deploy your Motia flows reliably across environments using the CLI."
    href="/docs/foundations/deployment"
  />
  <Card
    title="âœ… State Best Practices"
    description="Discover best practices to get the most out of the state manager in Motia."
    href="/docs/foundations/happy-practices#best-practices-of-using-state-manager"
  />
</Cards>